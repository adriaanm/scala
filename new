diff --git c/src/compiler/scala/tools/nsc/CompilationUnits.scala w/src/compiler/scala/tools/nsc/CompilationUnits.scala
index 15d365ab8c..219ff9c39b 100644
--- c/src/compiler/scala/tools/nsc/CompilationUnits.scala
+++ w/src/compiler/scala/tools/nsc/CompilationUnits.scala
@@ -65,27 +65,30 @@ trait CompilationUnits { self: Global =>
     private[this] val _defined = mutable.HashSet[Symbol]()
     def defined = if (exists && !source.file.isVirtual) _defined else mutable.HashSet[Symbol]()

-    /** Synthetic definitions generated by namer, eliminated by typer.
+    // object synthetics {
+    //   private val map = mutable.HashMap[Symbol, Tree]()
+    //   def update(sym: Symbol, tree: Tree) {
+    //     debuglog(s"adding synthetic ($sym, $tree) to $self")
+    //     map.update(sym, tree)
+    //   }
+    //   def -=(sym: Symbol) {
+    //     debuglog(s"removing synthetic $sym from $self")
+    //     map -= sym
+    //   }
+    //   def get(sym: Symbol): Option[Tree] = logResultIf[Option[Tree]](s"found synthetic for $sym in $self", _.isDefined) {
+    //     map get sym
+    //   }
+    //   def keys: Iterable[Symbol] = map.keys
+    //   def clear(): Unit = map.clear()
+    //   override def toString = map.toString
+    // }
+
+    /** Maps recording definitions that get created from namers and are later inserted
+     *  by typers.
      */
-    object synthetics {
-      private val map = mutable.HashMap[Symbol, Tree]()
-      def update(sym: Symbol, tree: Tree) {
-        debuglog(s"adding synthetic ($sym, $tree) to $self")
-        map.update(sym, tree)
-      }
-      def -=(sym: Symbol) {
-        debuglog(s"removing synthetic $sym from $self")
-        map -= sym
-      }
-      def get(sym: Symbol): Option[Tree] = logResultIf[Option[Tree]](s"found synthetic for $sym in $self", _.isDefined) {
-        map get sym
-      }
-      def keys: Iterable[Symbol] = map.keys
-      def clear(): Unit = map.clear()
-      override def toString = map.toString
-    }
-
-    /** things to check at end of compilation unit */
+    val lateDefs = new LateDefs
+
+     /** things to check at end of compilation unit */
     val toCheck = new ListBuffer[() => Unit]

     /** The features that were already checked for this unit */
diff --git c/src/compiler/scala/tools/nsc/Global.scala w/src/compiler/scala/tools/nsc/Global.scala
index f1fccd6069..a2b703ed7b 100644
--- c/src/compiler/scala/tools/nsc/Global.scala
+++ w/src/compiler/scala/tools/nsc/Global.scala
@@ -39,6 +39,7 @@ class Global(var currentSettings: Settings, var reporter: Reporter)
     with Trees
     with Printers
     with DocComments
+    with LateDefinitions
     with Positions { self =>

   // the mirror --------------------------------------------------
diff --git c/src/compiler/scala/tools/nsc/settings/ScalaSettings.scala w/src/compiler/scala/tools/nsc/settings/ScalaSettings.scala
index fe9165203f..f53b64f7e9 100644
--- c/src/compiler/scala/tools/nsc/settings/ScalaSettings.scala
+++ w/src/compiler/scala/tools/nsc/settings/ScalaSettings.scala
@@ -172,6 +172,7 @@ trait ScalaSettings extends AbsScalaSettings
   val etaExpandKeepsStar = BooleanSetting ("-Yeta-expand-keeps-star", "Eta-expand varargs methods to T* rather than Seq[T].  This is a temporary option to ease transition.").
                                           withDeprecationMessage("This flag is scheduled for removal in 2.12. If you have a case where you need this flag then please report a bug.")
   val Yinvalidate     = StringSetting     ("-Yinvalidate", "classpath-entry", "Invalidate classpath entry before run", "")
+  val Yxnamer         = BooleanSetting    ("-Yxnamer", "Use experimental namer scheme")
   val YvirtClasses    = false // too embryonic to even expose as a -Y //BooleanSetting    ("-Yvirtual-classes", "Support virtual classes")
   val YdisableUnreachablePrevention = BooleanSetting("-Ydisable-unreachable-prevention", "Disable the prevention of unreachable blocks in code generation.")

diff --git c/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala w/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala
index 02e1eb6f00..682aea5049 100644
--- c/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala
+++ w/src/compiler/scala/tools/nsc/typechecker/Analyzer.scala
@@ -13,6 +13,7 @@ import scala.reflect.internal.util.Statistics
 trait Analyzer extends AnyRef
             with Contexts
             with Namers
+            with NewNamers
             with Typers
             with Infer
             with Implicits
@@ -29,6 +30,8 @@ trait Analyzer extends AnyRef
   val global : Global
   import global._

+  val xNamer = settings.Yxnamer.value
+
   object namerFactory extends SubComponent {
     val global: Analyzer.this.global.type = Analyzer.this.global
     val phaseName = "namer"
diff --git c/src/compiler/scala/tools/nsc/typechecker/DerivedDefs.scala w/src/compiler/scala/tools/nsc/typechecker/DerivedDefs.scala
new file mode 100644
index 0000000000..1b9d989435
--- /dev/null
+++ w/src/compiler/scala/tools/nsc/typechecker/DerivedDefs.scala
@@ -0,0 +1,279 @@
+package scala.tools.nsc
+package typechecker
+
+import symtab.Flags._
+import scala.collection.{ mutable, immutable }
+import scala.tools.util.StringOps.{ ojoin }
+
+trait Derivers { this: Analyzer =>
+
+  import global._
+  import definitions._
+
+  trait Deriver { self: NewNamer =>
+
+    import NamerErrorGen._
+
+    /** A helper class that simplifies the creation of definitions that are
+     *  in some way derived from an `original` definition.
+     *  The main value that needs to be defined in subclasses is `derivedTree`,
+     *  which returns the unattributed tree of the derived definition.
+     *  The main method called by clients of this class is `enterLateDef`,
+     *  which enters the definition into the typechecking process and
+     *  returns `derivedTree` with a symbol representing the definition.
+     */
+    abstract class DefGen(original: MemberDef) {
+
+      /** The name of the derived method */
+      def name: TermName
+
+      /** Which meta-annotation is associated with this kind of entity.
+       *  Presently one of: field, getter, setter, beanGetter, beanSetter, param,
+       *  companionClass, companionObject, companionMethod.
+       */
+      def annotCategory: Symbol
+
+      /** Should annotations whose definitions are not meta-annotated be kept? */
+      def keepCleanAnnots: Boolean = false
+
+      /** The flags that are retained from the original symbol */
+      def flagsMask: Long
+
+      /** The flags that the derived symbol has in addition to those retained from
+       *  the original symbol*/
+      def flagsExtra: Long
+
+      /** The flags of the derived definition; may be overridden in subclasses */
+      def derivedFlags = original.mods.flags & flagsMask | flagsExtra
+
+      /** The modifiers of the derived definition; may be overridden in subclasses */
+      def derivedMods = Modifiers(derivedFlags, original.mods.privateWithin)
+
+      /** The definition tree of the derived symbol.
+       *  If it's a lazy val, it will be forced by enterLateDef.
+       */
+      val derivedTree: MemberDef
+
+      /** The symbol of the derived tree; valid after enterLateDef has been called */
+      def derivedSym: Symbol =
+        derivedTree.symbol orElse {
+          throw new AssertionError("can't get a derivedSym before enterLateDef is called")
+        }
+
+      /** A hook for typer-time validations of this definition, called from postProcess */
+      def validate(): Unit = {}
+
+      /** A postprocessing operation which is invoked during Typers at the time where the
+       *  tree is inserted into the enclosing statement sequence. By default this does
+       *  validation and annotation processing
+       */
+      def postProcess(tree: Tree): Tree = {
+        validate()
+        derivedSym setAnnotations deriveAnnotations(original, annotCategory, keepCleanAnnots)
+        logDerived(tree)
+      }
+
+      private def logDerived(result: Tree): Tree = {
+       debuglog("[+derived] " + ojoin(result.symbol.accurateKindString, result.symbol.getterName.decode)
+         + " (" + derivedSym + ")\n        " + result)
+       result
+     }
+
+     /** Creates a late definition; creates and enters its symbol, returns it.
+      *  Sets original.symbol to newly created symbol unless it's already defined.
+      */
+     def enterLateDef(): MemberDef = {
+        val sym = self.enterLateDef(derivedTree, original.symbol, postProcess)
+        if (original.symbol == NoSymbol) original.symbol = sym
+        derivedTree
+      }
+    }
+
+    /** The annotations amongst those found on the original symbol which
+     * should be propagated to this kind of accessor.
+     */
+    private def deriveAnnotations(original: Tree, annotCategory: Symbol, keepCleanAnnots: Boolean): List[AnnotationInfo] = {
+      original.symbol.initialize.annotations filter { ann =>
+        // There are no meta-annotation arguments attached to `ann`
+        if (ann.metaAnnotations.isEmpty) {
+          // A meta-annotation matching `annotCategory` exists on `ann`'s definition.
+          (ann.defaultTargets contains annotCategory) ||
+          // `ann`'s definition has no meta-annotations, and `keepCleanAnnots` is true.
+          (ann.defaultTargets.isEmpty && keepCleanAnnots)
+        }
+        // There are meta-annotation arguments, and one of them matches `annotCategory`
+        else ann.metaAnnotations exists (_ matches annotCategory)
+      }
+    }
+
+    /** Enters an implicit conversion method for an implicit class */
+    def enterImplicitWrapper(original: ClassDef) = {
+      class ImplicitClassWrapperGen extends DefGen(original) {
+        def flagsMask = AccessFlags
+        def flagsExtra = METHOD | IMPLICIT
+        def name = nme.implicitWrapperName(original.name)
+        def annotCategory = MethodTargetClass
+        lazy val derivedTree = factoryMeth(derivedMods, name, original)
+      }
+      new ImplicitClassWrapperGen().enterLateDef()
+    }
+
+    /** Enters all definitions (setters/getters/fields) associated with a val or var.
+     *
+     *  The architecture of that method is somewhat special: It's a long method
+     *  where value definitions are interspersed with embedded classes.
+     *
+     *  This tells a story: How fields, then getters, then setters, then beans are
+     *  defined. Every step may refer to symbols defined in the previous steps.
+     *  The embedded classes appear at a point where everything before them
+     *  is defined and everything after them is off limits. The embedded
+     *  classes profit from systematic code reuse by inheriting from each other
+     *  and the common superclass derivedDef.
+     *
+     *  So we have two axes of references here: Inherited ones which capture
+     *  commonality of field and accessor definitions, and scoped ones, which
+     *  capture the flow of definitions.
+     *
+     *  The 2.9 version of this complex captured flow but was bad at reuse because all accessors
+     *  were defined directly in long methods. The previous 2.10 version captured
+     *  reuse well but it was very hard to see what got defined when and was available
+     *  to whom. The new design here captured both dimensions equally well.
+     */
+    def enterAllValDef(original: ValDef) = {
+      val origMods = original.mods
+
+      // preliminary checks
+      if (origMods.isPrivateLocal)
+        PrivateThisCaseClassParameterError(original)
+      if (nme.isSetterName(original.name))
+        ValOrValWithSetterSuffixError(original)
+
+      // generate the field
+      class FieldGen extends DefGen(original) {
+        def flagsMask = FieldFlags
+        def flagsExtra = PrivateLocal
+        def name = nme.getterToLocal(original.name)
+        def annotCategory = FieldTargetClass
+        // By default annotations go to the field, except if the field is
+        // generated for a class parameter (PARAMACCESSOR).
+        override def keepCleanAnnots = !origMods.isParamAccessor
+        lazy val derivedTree = atPos(original.pos) {
+          ValDef(derivedMods, name, original.tpt, original.rhs)
+        }
+      }
+
+      val field = if (origMods.isDeferred) EmptyTree else new FieldGen().enterLateDef()
+
+      // utility methods for subsequent steps
+      def fieldSelection =
+        if (field.symbol.owner.isTerm) Ident(field.symbol)
+        else Select(This(field.symbol.owner), field.symbol)
+
+      def setterParamName = nme.syntheticParamName(1)
+      def initialization = Assign(fieldSelection, Ident(setterParamName))
+
+      // generate the getter
+      class GetterGen extends DefGen(original) {
+        def flagsMask  = GetterFlags
+        def flagsExtra = ACCESSOR | ( if (origMods.isMutable) 0 else STABLE )
+        def name = nme.getterName(original.name)
+        def annotCategory = GetterTargetClass
+
+        /** Check that any BeanProperty annotations appear under their proper name,
+         *  and that no annotation named BeanProperty means something else.
+         *  This is necessary because beans are created before annotations can
+         *  be name-resolved.
+         */
+        private def validateBeanAnnot(beanAnnot: Symbol) {
+          if ((original.symbol hasAnnotation beanAnnot) !=
+              (original.mods hasAnnotationNamed beanAnnot.name.toTypeName))
+            BeanPropertyAnnotationLimitationError(original)
+        }
+        override def validate() {
+          if (derivedSym.isOverloaded) GetterDefinedTwiceError(derivedSym)
+          validateBeanAnnot(BeanPropertyAttr)
+          validateBeanAnnot(BooleanBeanPropertyAttr)
+          super.validate()
+        }
+
+        def vparamss: List[List[ValDef]] = Nil
+        val (tpt, rhs, pos) =
+          if (origMods.isDeferred)
+            (original.tpt, EmptyTree, original.pos)
+          else {
+            // For existentials, don't specify a type for the getter, even one derived
+            // from the symbol! This leads to incompatible existentials for the field and
+            // the getter. Let the typer do all the work. You might think "why only for
+            // existentials, why not always," and you would be right, except: a single test
+            // fails, but it looked like some work to deal with it. Test neg/t0606.scala
+            // starts compiling (instead of failing like it's supposed to) because the typer
+            // expects to be able to identify escaping locals in typedDefDef, and fails to
+            // spot that brand of them. In other words it's an artifact of the implementation.
+            val duptpt = field.symbol.tpe match {
+              case ExistentialType(_, _) => TypeTree()
+              case tp => TypeTree(tp)
+            }
+            var init = gen.mkCheckInit(fieldSelection)
+            if (original.mods.isLazy) init = Block(List(initialization), init)
+            (duptpt, init, original.pos.focus)
+          }
+        lazy val derivedTree = atPos(pos) {
+          DefDef(derivedMods, name, Nil, vparamss, tpt, rhs)
+        }
+      }
+
+      val getter = new GetterGen().enterLateDef()
+
+      // generate the setter
+      class SetterGen extends DefGen(original) {
+        def flagsMask = SetterFlags
+        def flagsExtra = ACCESSOR
+        def name = nme.getterToSetter(getter.name)
+        def annotCategory = SetterTargetClass
+        val setterParam = ValDef(
+          Modifiers(PARAM), setterParamName, TypeTree(getter.symbol.tpe.finalResultType), EmptyTree)
+        lazy val derivedTree = atPos(original.pos.focus) {
+          DefDef(derivedMods, name, Nil, List(List(setterParam)), TypeTree(UnitClass.tpe),
+          if (original.mods.isDeferred) EmptyTree else initialization)
+        }
+      }
+
+      if (original.mods.isMutable) new SetterGen().enterLateDef()
+
+      // generate any bean accessors
+      trait BeanGen extends DefGen {
+        protected def prefix: String
+        override def flagsMask  = BeanPropertyFlags
+        override def flagsExtra = 0
+        override def name = newTermName(prefix + original.name.toString.capitalize)
+      }
+
+      class BeanGetterGen(val prefix: String) extends GetterGen with BeanGen {
+        override def annotCategory = BeanGetterTargetClass
+        override def vparamss: List[List[ValDef]] = List(Nil)
+      }
+
+      class BeanSetterGen extends SetterGen with BeanGen {
+        def prefix = "set"
+        override def annotCategory = BeanSetterTargetClass
+      }
+
+      def makeBeans(prefix: String): Unit = {
+        if (!original.name(0).isLetter)
+          BeanPropertyAnnotationFieldWithoutLetterError(original)
+        else if (original.mods.isPrivate)  // avoids name clashes with private fields in traits
+          BeanPropertyAnnotationPrivateFieldError(original)
+        new BeanGetterGen(prefix).enterLateDef()
+        if (original.mods.isMutable) new BeanSetterGen().enterLateDef()
+      }
+
+      if (!forMSIL)
+        if (original.mods hasAnnotationNamed tpnme.BeanPropertyAnnot) makeBeans("get")
+        else if (original.mods hasAnnotationNamed tpnme.BooleanBeanPropertyAnnot) makeBeans("is")
+    }
+
+    def validateParam(tree: ValDef) {
+      tree.symbol setAnnotations deriveAnnotations(tree, ParamTargetClass, true)
+    }
+  }
+}
\ No newline at end of file
diff --git c/src/compiler/scala/tools/nsc/typechecker/LateDefinitions.scala w/src/compiler/scala/tools/nsc/typechecker/LateDefinitions.scala
new file mode 100644
index 0000000000..ee4987f3c3
--- /dev/null
+++ w/src/compiler/scala/tools/nsc/typechecker/LateDefinitions.scala
@@ -0,0 +1,60 @@
+package scala.tools.nsc
+package typechecker
+
+import collection.mutable
+import reflect.internal.Flags._
+
+trait LateDefinitions { self: Global =>
+
+  /** Maps symbols to the definitions they generate.
+   *  The maps are populated in Namers and bindings are removed again in Typers.
+   */
+  class LateDefs {
+    /** Maps symbols to the late trees that define them */
+    private val lateDefs = mutable.Map[Symbol, LateDef]()
+
+    /** Maps symbols to the symbols that depend on them (e.g. field -> getter/setter,
+     *  method -> default argument, class -> companion object) */
+    private val dependentSymbols = new mutable.HashMap[Symbol, List[Symbol]] {
+      override def default(key: Symbol) = List()
+    }
+
+    /** Clear all maps */
+    def clear() {
+      lateDefs.clear()
+      dependentSymbols.clear()
+    }
+
+    /** Enter a tree into maps
+     *  @param  tree    The tree to be inserted at Typers. This must be a definition with a defined symbol.
+     *  @param original If the tree was created as a supplementary method for some original definition,
+     *                  the symbol of the original definition. Otherwise NoSymbol.
+     *                  Dependent definitions will be inserted after their original definitions.
+     *                  Original symbols that do not share the same owner with the tree's symbol are ignored.
+     */
+    def enterTree(tree: Tree, original: Symbol = NoSymbol, postProcess: Tree => Tree = identity): Unit = {
+      lateDefs(tree.symbol) = new LateDef(t => postProcess(tree))
+      if (original != NoSymbol && original.owner == tree.symbol.owner) {
+        dependentSymbols(original) :+= tree.symbol
+      }
+    }
+
+    def enterWrapper(sym: Symbol, trans: Tree => Tree): Unit =
+      lateDefs(sym) = new LateDef(
+        lateDefs get sym match {
+          case Some(ldef) => ldef.trans andThen trans
+          case None => trans
+        }
+      )
+
+    /** Remove symbol from maps, and return its associated tree and dependent symbols */
+    def remove(sym: Symbol): (LateDef, List[Symbol]) =
+      (lateDefs remove sym getOrElse NoLateDef, dependentSymbols remove sym getOrElse Nil)
+
+  }
+
+  class LateDef(val trans: Tree => Tree)
+
+  val NoLateDef = new LateDef(identity)
+
+}
diff --git c/src/compiler/scala/tools/nsc/typechecker/MethodSynthesis.scala w/src/compiler/scala/tools/nsc/typechecker/MethodSynthesis.scala
index 50383a1e78..fae0bed131 100644
--- c/src/compiler/scala/tools/nsc/typechecker/MethodSynthesis.scala
+++ w/src/compiler/scala/tools/nsc/typechecker/MethodSynthesis.scala
@@ -137,7 +137,7 @@ trait MethodSynthesis {
    *   part of the typed template.
    */
   trait MethodSynth {
-    self: Namer =>
+    self: NormalNamer =>

     import NamerErrorGen._

@@ -363,7 +363,7 @@ trait MethodSynthesis {
      */
     case class ImplicitClassWrapper(tree: ClassDef) extends DerivedFromClassDef {
       def completer(sym: Symbol): Type = ??? // not needed
-      def createAndEnterSymbol(): Symbol = enterSyntheticSym(derivedTree)
+      def createAndEnterSymbol(): Symbol = enterLateDef(derivedTree, tree.symbol)
       def derivedSym: Symbol = {
         // Only methods will do! Don't want to pick up any stray
         // companion objects of the same name.
@@ -530,7 +530,7 @@ trait MethodSynthesis {
           )
         }
       }
-      override def createAndEnterSymbol(): Symbol = enterSyntheticSym(derivedTree)
+      override def createAndEnterSymbol(): Symbol = enterLateDef(derivedTree)
     }
     case class BooleanBeanGetter(tree: ValDef) extends BeanAccessor("is") with AnyBeanGetter { }
     case class BeanGetter(tree: ValDef) extends BeanAccessor("get") with AnyBeanGetter { }
diff --git c/src/compiler/scala/tools/nsc/typechecker/Namers.scala w/src/compiler/scala/tools/nsc/typechecker/Namers.scala
index 55f144da13..9567bd525c 100644
--- c/src/compiler/scala/tools/nsc/typechecker/Namers.scala
+++ w/src/compiler/scala/tools/nsc/typechecker/Namers.scala
@@ -28,7 +28,7 @@ trait Namers extends MethodSynthesis {
   /** Replaces any Idents for which cond is true with fresh TypeTrees().
    *  Does the same for any trees containing EmptyTrees.
    */
-  private class TypeTreeSubstituter(cond: Name => Boolean) extends Transformer {
+  private[typechecker] class TypeTreeSubstituter(cond: Name => Boolean) extends Transformer {
     override def transform(tree: Tree): Tree = tree match {
       case Ident(name) if cond(name) => TypeTree()
       case _                         => super.transform(tree)
@@ -40,26 +40,42 @@ trait Namers extends MethodSynthesis {
     }
   }

-  private def isTemplateContext(ctx: Context): Boolean = ctx.tree match {
+  private[typechecker] def isTemplateContext(ctx: Context): Boolean = ctx.tree match {
     case Template(_, _, _) => true
     case Import(_, _)      => isTemplateContext(ctx.outer)
     case _                 => false
   }

-  private class NormalNamer(context: Context) extends Namer(context)
-  def newNamer(context: Context): Namer = new NormalNamer(context)
+  abstract class Namer extends NamerContextErrors {
+    type ThisNamer <: Namer
+    def context: Context
+    def enterInScope(sym: Symbol): Symbol
+    def enterIfNotThere(sym: Symbol)
+    def enterSym(tree: Tree): Context
+    def enterSyms(trees: List[Tree]): Namer
+    def enterLateDef(tree: Tree, original: Symbol = NoSymbol, postProcess: Tree => Tree = identity): Symbol
+    def ensureCompanionObject(cdef: ClassDef, creator: ClassDef => Tree = companionModuleDef(_)): Symbol
+    def enterValueParams(vparamss: List[List[ValDef]]): List[List[Symbol]]
+    def addDerivedTrees(typer: Typer, stat: Tree): List[Tree]
+    def validateParam(tree: ValDef)
+  }
+
+  def newNamer(context: Context): Namer =
+    if (xNamer) new NewNamer(context) else new NormalNamer(context)

-  abstract class Namer(val context: Context) extends MethodSynth with NamerContextErrors { thisNamer =>
+  class NormalNamer(val context: Context) extends Namer with MethodSynth { thisNamer =>
     // overridden by the presentation compiler
     def saveDefaultGetter(meth: Symbol, default: Symbol) { }

+    type ThisNamer = NormalNamer
+
     import NamerErrorGen._
     val typer = newTyper(context)

-    private lazy val innerNamer =
+    private lazy val innerNamer: ThisNamer =
       if (isTemplateContext(context)) createInnerNamer() else this

-    def createNamer(tree: Tree): Namer = {
+    def createNamer(tree: Tree): ThisNamer = {
       val sym = tree match {
         case ModuleDef(_, _, _) => tree.symbol.moduleClass
         case _                  => tree.symbol
@@ -75,18 +91,18 @@ trait Namers extends MethodSynthesis {
         case _ =>
           context
       }
-      newNamer(ownerCtx.makeNewScope(tree, sym))
+      newNamer(ownerCtx.makeNewScope(tree, sym)).asInstanceOf[ThisNamer]
     }
-    def createInnerNamer() = {
-      newNamer(context.make(context.tree, owner, newScope))
+    def createInnerNamer(): ThisNamer = {
+      newNamer(context.make(context.tree, owner, newScope)).asInstanceOf[ThisNamer]
     }
-    def createPrimaryConstructorParameterNamer: Namer = { //todo: can we merge this with SCCmode?
+    def createPrimaryConstructorParameterNamer: ThisNamer = { //todo: can we merge this with SCCmode?
       val classContext = context.enclClass
       val outerContext = classContext.outer.outer
       val paramContext = outerContext.makeNewScope(outerContext.tree, outerContext.owner)

       owner.unsafeTypeParams foreach (paramContext.scope enter _)
-      newNamer(paramContext)
+      newNamer(paramContext).asInstanceOf[ThisNamer]
     }

     def enclosingNamerWithScope(scope: Scope) = {
@@ -162,7 +178,7 @@ trait Namers extends MethodSynthesis {
       }
       sym
     }
-    def namerOf(sym: Symbol): Namer = {
+    def namerOf(sym: Symbol): ThisNamer = {
       val usePrimary = sym.isTerm && (
            (sym.isParamAccessor)
         || (sym.isParameter && sym.owner.isPrimaryConstructor)
@@ -223,11 +239,13 @@ trait Namers extends MethodSynthesis {
             handleSyntheticNameConflict(sym, prev.sym)
             handleSyntheticNameConflict(prev.sym, sym)
           }
+          debugwarn(s"Overloading conflict ${sym.name}#${sym.id} ${flagsToString(sym.flags)} was #${prev.sym.id} ${flagsToString(prev.sym.flags)}")
           DoubleDefError(sym, prev.sym)
           sym setInfo ErrorType
           scope unlink prev.sym // let them co-exist...
           // FIXME: The comment "let them co-exist" is confusing given that the
           // line it comments unlinks one of them.  What does it intend?
+          // [Martin] Unlinking does not mean that the symbol goes away.
         }
       }
       scope enter sym
@@ -251,7 +269,9 @@ trait Namers extends MethodSynthesis {
           case tree @ ValDef(_, _, _, _)                     => enterValDef(tree)
           case tree @ DefDef(_, _, _, _, _, _)               => enterDefDef(tree)
           case tree @ TypeDef(_, _, _, _)                    => enterTypeDef(tree)
-          case DocDef(_, defn)                               => enterSym(defn)
+          case DocDef(doc, defn)                               =>
+            enterSym(defn)
+            context.unit.lateDefs.enterWrapper(defn.symbol, treeCopy.DocDef(tree, doc, _))
           case tree @ Import(_, _)                           =>
             assignSymbol(tree)
             returnContext = context.make(tree)
@@ -432,7 +452,7 @@ trait Namers extends MethodSynthesis {
         updatePosFlags(m, tree.pos, moduleFlags)
         setPrivateWithin(tree, m)
         m.moduleClass andAlso (setPrivateWithin(tree, _))
-        context.unit.synthetics -= m
+        context.unit.lateDefs.remove(m)
         tree.symbol = m
       }
       else {
@@ -487,7 +507,7 @@ trait Namers extends MethodSynthesis {
       // The object Foo is still in scope, but because it is not compiled in current run
       // it should be ditched and a new one created.
       if (m != NoSymbol && currentRun.compiles(m)) m
-      else enterSyntheticSym(atPos(cdef.pos.focus)(creator(cdef)))
+      else enterLateDef(atPos(cdef.pos.focus)(creator(cdef)), cdef.symbol)
     }

     private def checkSelectors(tree: Import): Unit = {
@@ -694,9 +714,10 @@ trait Namers extends MethodSynthesis {
     def enterExistingSym(sym: Symbol): Context = this.context
     def enterIfNotThere(sym: Symbol) { }

-    def enterSyntheticSym(tree: Tree): Symbol = {
+    def enterLateDef(tree: Tree, original: Symbol = NoSymbol, postProcess: Tree => Tree = identity): Symbol = {
       enterSym(tree)
-      context.unit.synthetics(tree.symbol) = tree
+      context.unit.lateDefs.enterTree(tree, original, postProcess)
+      log("enter late "+tree.symbol+" from "+original)
       tree.symbol
     }

@@ -822,19 +843,25 @@ trait Namers extends MethodSynthesis {
         else tpe.deconst
       )
     }
+
     /** Computes the type of the body in a ValDef or DefDef, and
-     *  assigns the type to the tpt's node.  Returns the type.
+     *  assigns the type to the tpt's node. lateDef.enters the definition with the transformed
+     *  rhs for later integration during type checking.
+     *  Returns the type.
      */
-    private def assignTypeToTree(tree: ValOrDefDef, defnTyper: Typer, pt: Type): Type = {
-      val rhsTpe =
-        if (tree.symbol.isTermMacro) defnTyper.computeMacroDefType(tree, pt)
-        else defnTyper.computeType(tree.rhs, pt)
-
-      val defnTpe = widenIfNecessary(tree.symbol, rhsTpe, pt)
-      tree.tpt defineType defnTpe setPos tree.pos.focus
-      tree.tpt.tpe
+    private def inferTypeOfTree(tree: ValOrDefDef, defnTyper: Typer, pt: Type)(copier: (Tree, Tree) => ValOrDefDef): Type = {
+      // compute result type from rhs
+      // TODO: if (tree.symbol.isTermMacro) defnTyper.computeMacroDefTypeFromMacroImpl(tree, pt)
+      val (rhs1, rhsType) = defnTyper.packedTyped(tree.rhs, pt)
+      val defnType = widenIfNecessary(if (owner.isMethod) owner else tree.symbol, rhsType, pt)
+      (tree.tpt defineType defnType) setPos tree.pos.focus
+      context.unit.lateDefs.enterWrapper(tree.symbol, copier(_, rhs1))
+      tree.symbol setFlag INFERRED
+      defnType
+      //println("infer: "+tree1)
     }

+
     // owner is the class with the self type
     def enterSelf(self: ValDef) {
       val ValDef(_, name, tpt, _) = self
@@ -1151,7 +1178,9 @@ trait Namers extends MethodSynthesis {
             //   trait T { def f: Object }; class C <: T { def f = "" }
             // using resTpFromOverride as expected type allows for the following (C.f has type A):
             //   trait T { def f: A }; class C <: T { implicit def b2a(t: B): A = ???; def f = new B }
-            assignTypeToTree(ddef, typer, resTpFromOverride)
+            inferTypeOfTree(ddef, typer, resTpFromOverride) {
+              treeCopy.DefDef(_, ddef.mods, ddef.name, ddef.tparams, ddef.vparamss, ddef.tpt, _)
+            }
           })
         // #2382: return type of default getters are always @uncheckedVariance
         if (meth.hasDefault)
@@ -1272,7 +1301,7 @@ trait Namers extends MethodSynthesis {
             }
             if (!isConstr)
               methOwner.resetFlag(INTERFACE) // there's a concrete member now
-            val default = parentNamer.enterSyntheticSym(defaultTree)
+            val default = parentNamer.enterLateDef(defaultTree, meth)
             if (default.owner.isTerm)
               saveDefaultGetter(meth, default)
           }
@@ -1296,7 +1325,7 @@ trait Namers extends MethodSynthesis {
           MissingParameterOrValTypeError(tpt)
           ErrorType
         }
-        else assignTypeToTree(vdef, typer, WildcardType)
+        else inferTypeOfTree(vdef, typer, WildcardType) { treeCopy.ValDef(_, vdef.mods, vdef.name, vdef.tpt, _) }
       } else {
         typer.typedType(tpt).tpe
       }
@@ -1354,7 +1383,7 @@ trait Namers extends MethodSynthesis {

         val newImport = treeCopy.Import(imp, expr1, selectors).asInstanceOf[Import]
         checkSelectors(newImport)
-        transformed(imp) = newImport
+        context.unit.lateDefs.enter(newImport)
         // copy symbol and type attributes back into old expression
         // so that the structure builder will find it.
         expr setSymbol expr1.symbol setType expr1.tpe
@@ -1362,7 +1391,6 @@ trait Namers extends MethodSynthesis {
       }
     }

-
     /** Given a case class
      *   case class C[Ts] (ps: Us)
      *  Add the following methods to toScope:
@@ -1377,15 +1405,15 @@ trait Namers extends MethodSynthesis {
      */
     def addApplyUnapply(cdef: ClassDef, namer: Namer) {
       if (!cdef.symbol.hasAbstractFlag)
-        namer.enterSyntheticSym(caseModuleApplyMeth(cdef))
+        namer.enterLateDef(caseModuleApplyMeth(cdef))

       val primaryConstructorArity = treeInfo.firstConstructorArgs(cdef.impl.body).size
       if (primaryConstructorArity <= MaxTupleArity)
-        namer.enterSyntheticSym(caseModuleUnapplyMeth(cdef))
+        namer.enterLateDef(caseModuleUnapplyMeth(cdef))
     }

     def addCopyMethod(cdef: ClassDef, namer: Namer) {
-      caseClassCopyMeth(cdef) foreach namer.enterSyntheticSym
+      caseClassCopyMeth(cdef) foreach (namer.enterLateDef(_))
     }

     /**
@@ -1648,7 +1676,7 @@ trait Namers extends MethodSynthesis {
   //    def foo[T, T2](a: T, x: T2)(implicit w: ComputeT2[T, T2])
   // moreover, the latter is not an encoding of the former, which hides type
   // inference of T2, so you can specify T while T2 is purely computed
-  private class DependentTypeChecker(ctx: Context)(namer: Namer) extends TypeTraverser {
+  private[typechecker] class DependentTypeChecker(ctx: Context)(namer: Namer) extends TypeTraverser {
     private[this] val okParams = mutable.Set[Symbol]()
     private[this] val method   = ctx.owner

diff --git c/src/compiler/scala/tools/nsc/typechecker/Namers.scala w/src/compiler/scala/tools/nsc/typechecker/NewNamers.scala
similarity index 52%
copy from src/compiler/scala/tools/nsc/typechecker/Namers.scala
copy to src/compiler/scala/tools/nsc/typechecker/NewNamers.scala
index 55f144da13..d446ec108a 100644
--- c/src/compiler/scala/tools/nsc/typechecker/Namers.scala
+++ w/src/compiler/scala/tools/nsc/typechecker/NewNamers.scala
@@ -1,5 +1,5 @@
 /* NSC -- new Scala compiler
- * Copyright 2005-2013 LAMP/EPFL
+ * Copyright 2005-2011 LAMP/EPFL
  * @author  Martin Odersky
  */

@@ -8,85 +8,47 @@ package typechecker

 import scala.collection.mutable
 import scala.annotation.tailrec
+import scala.ref.WeakReference
 import symtab.Flags._
-import scala.language.postfixOps
+import scala.tools.nsc.io.AbstractFile

 /** This trait declares methods to create symbols and to enter them into scopes.
  *
  *  @author Martin Odersky
  *  @version 1.0
  */
-trait Namers extends MethodSynthesis {
-  self: Analyzer =>
+trait NewNamers extends Derivers { self: Analyzer =>

   import global._
   import definitions._

-  private var _lockedCount = 0
-  def lockedCount = this._lockedCount
+  class NewNamer(val context: Context) extends Namer with Deriver { thisNamer =>

-  /** Replaces any Idents for which cond is true with fresh TypeTrees().
-   *  Does the same for any trees containing EmptyTrees.
-   */
-  private class TypeTreeSubstituter(cond: Name => Boolean) extends Transformer {
-    override def transform(tree: Tree): Tree = tree match {
-      case Ident(name) if cond(name) => TypeTree()
-      case _                         => super.transform(tree)
-    }
-    def apply(tree: Tree) = {
-      val r = transform(tree)
-      if (r.exists(_.isEmpty)) TypeTree()
-      else r
-    }
-  }
-
-  private def isTemplateContext(ctx: Context): Boolean = ctx.tree match {
-    case Template(_, _, _) => true
-    case Import(_, _)      => isTemplateContext(ctx.outer)
-    case _                 => false
-  }
-
-  private class NormalNamer(context: Context) extends Namer(context)
-  def newNamer(context: Context): Namer = new NormalNamer(context)
-
-  abstract class Namer(val context: Context) extends MethodSynth with NamerContextErrors { thisNamer =>
-    // overridden by the presentation compiler
-    def saveDefaultGetter(meth: Symbol, default: Symbol) { }
+    type ThisNamer = NewNamer

     import NamerErrorGen._
     val typer = newTyper(context)

-    private lazy val innerNamer =
+    private lazy val innerNamer: ThisNamer =
       if (isTemplateContext(context)) createInnerNamer() else this

-    def createNamer(tree: Tree): Namer = {
+    def createNamer(tree: Tree): ThisNamer = {
       val sym = tree match {
         case ModuleDef(_, _, _) => tree.symbol.moduleClass
         case _                  => tree.symbol
       }
-      def isConstrParam(vd: ValDef) = {
-        (sym hasFlag PARAM | PRESUPER) &&
-        !vd.mods.isJavaDefined &&
-        sym.owner.isConstructor
-      }
-      val ownerCtx = tree match {
-        case vd: ValDef if isConstrParam(vd) =>
-          context.makeConstructorContext
-        case _ =>
-          context
-      }
-      newNamer(ownerCtx.makeNewScope(tree, sym))
+      newNamer(context.makeNewScope(tree, sym)).asInstanceOf[ThisNamer]
     }
-    def createInnerNamer() = {
-      newNamer(context.make(context.tree, owner, newScope))
+    def createInnerNamer(): ThisNamer = {
+      newNamer(context.make(context.tree, owner, newScope)).asInstanceOf[ThisNamer]
     }
-    def createPrimaryConstructorParameterNamer: Namer = { //todo: can we merge this with SCCmode?
+    def createPrimaryConstructorParameterNamer: ThisNamer = { //todo: can we merge this with SCCmode?
       val classContext = context.enclClass
       val outerContext = classContext.outer.outer
       val paramContext = outerContext.makeNewScope(outerContext.tree, outerContext.owner)

       owner.unsafeTypeParams foreach (paramContext.scope enter _)
-      newNamer(paramContext)
+      newNamer(paramContext).asInstanceOf[ThisNamer]
     }

     def enclosingNamerWithScope(scope: Scope) = {
@@ -123,34 +85,50 @@ trait Namers extends MethodSynthesis {
       || (context.unit.isJava)
     )
     def noFinishGetterSetter(vd: ValDef) = (
-         (vd.mods.isPrivateLocal && !vd.mods.isLazy) // all lazy vals need accessors, even private[this]
-      || vd.symbol.isModuleVar)
+         vd.mods.isPrivateLocal
+      || vd.symbol.isModuleVar
+      || vd.symbol.isLazy
+    )

-    def setPrivateWithin[T <: Symbol](tree: Tree, sym: T, mods: Modifiers): T =
+    def setPrivateWithin[Sym <: Symbol](tree: Tree, sym: Sym, mods: Modifiers): Sym =
       if (sym.isPrivateLocal || !mods.hasAccessBoundary) sym
-      else sym setPrivateWithin typer.qualifyingClass(tree, mods.privateWithin, packageOK = true)
+      else sym setPrivateWithin (
+        typer.qualifyingClass(tree, mods.privateWithin, true) match {
+          case None =>
+            NoSymbol
+          case Some(sym) =>
+            sym
+        }
+      )

     def setPrivateWithin(tree: MemberDef, sym: Symbol): Symbol =
       setPrivateWithin(tree, sym, tree.mods)

-    def inConstructorFlag: Long = {
-      val termOwnedContexts: List[Context] = context.enclosingContextChain.takeWhile(_.owner.isTerm)
-      val constructorNonSuffix = termOwnedContexts exists (c => c.owner.isConstructor && !c.inConstructorSuffix)
-      val earlyInit            = termOwnedContexts exists (_.owner.isEarlyInitialized)
-      if (constructorNonSuffix || earlyInit) INCONSTRUCTOR else 0L
-    }
+    def inConstructorFlag: Long =
+      if (owner.isConstructor && !context.inConstructorSuffix || owner.isEarlyInitialized) INCONSTRUCTOR
+      else 0l

     def moduleClassFlags(moduleFlags: Long) =
       (moduleFlags & ModuleToClassFlags) | inConstructorFlag

+    private def resetKeepingFlags(sym: Symbol, keeping: Long): Symbol = {
+      val keep = sym.flags & keeping
+      sym reset NoType
+      sym setFlag keep
+    }
+
     def updatePosFlags(sym: Symbol, pos: Position, flags: Long): Symbol = {
       debuglog("[overwrite] " + sym)
-      val newFlags = (sym.flags & LOCKED) | flags
-      sym reset NoType setFlag newFlags setPos pos
-      sym.moduleClass andAlso (updatePosFlags(_, pos, moduleClassFlags(flags)))
+      resetKeepingFlags(sym, LOCKED)
+      sym setFlag flags
+      sym setPos pos
+
+      if (sym.isModule && sym.moduleClass != NoSymbol)
+        updatePosFlags(sym.moduleClass, pos, moduleClassFlags(flags))

-      if (sym.isTopLevel) {
-        companionSymbolOf(sym, context) andAlso { companion =>
+      if (sym.owner.isPackageClass) {
+        val companion = companionSymbolOf(sym, context)
+        if (companion != NoSymbol) {
           val assignNoType = companion.rawInfo match {
             case _: SymLoader => true
             case tp           => tp.isComplete && (runId(sym.validTo) != currentRunId)
@@ -162,7 +140,7 @@ trait Namers extends MethodSynthesis {
       }
       sym
     }
-    def namerOf(sym: Symbol): Namer = {
+    def namerOf(sym: Symbol): ThisNamer = {
       val usePrimary = sym.isTerm && (
            (sym.isParamAccessor)
         || (sym.isParameter && sym.owner.isPrimaryConstructor)
@@ -172,24 +150,21 @@ trait Namers extends MethodSynthesis {
       else innerNamer
     }

-    // FIXME - this logic needs to be thoroughly explained
-    // and justified.  I know it's wrong with repect to package
-    // objects, but I think it's also wrong in other ways.
     protected def conflict(newS: Symbol, oldS: Symbol) = (
        (   !oldS.isSourceMethod
         || nme.isSetterName(newS.name)
-        || newS.isTopLevel
+        || newS.owner.isPackageClass
        ) &&
       !(   // @M: allow repeated use of `_` for higher-order type params
            (newS.owner.isTypeParameter || newS.owner.isAbstractType)
            // FIXME: name comparisons not successful, are these underscores
            // sometimes nme.WILDCARD and sometimes tpnme.WILDCARD?
-        && (newS.name string_== nme.WILDCARD)
+        && (newS.name.toString == nme.WILDCARD.toString)
        )
     )

     private def allowsOverload(sym: Symbol) = (
-      sym.isSourceMethod && sym.owner.isClass && !sym.isTopLevel
+      sym.isSourceMethod && sym.owner.isClass && !sym.owner.isPackageClass
     )

     private def inCurrentScope(m: Symbol): Boolean = {
@@ -202,45 +177,22 @@ trait Namers extends MethodSynthesis {

     /** Enter symbol into given scope and return symbol itself */
     def enterInScope(sym: Symbol, scope: Scope): Symbol = {
-      // FIXME - this is broken in a number of ways.
-      //
-      // 1) If "sym" allows overloading, that is not itself sufficient to skip
-      // the check, because "prev.sym" also must allow overloading.
-      //
-      // 2) There is nothing which reconciles a package's scope with
-      // the package object's scope.  This is the source of many bugs
-      // with e.g. defining a case class in a package object.  When
-      // compiling against classes, the class symbol is created in the
-      // package and in the package object, and the conflict is undetected.
-      // There is also a non-deterministic outcome for situations like
-      // an object with the same name as a method in the package object.
-
       // allow for overloaded methods
       if (!allowsOverload(sym)) {
         val prev = scope.lookupEntry(sym.name)
         if ((prev ne null) && prev.owner == scope && conflict(sym, prev.sym)) {
-          if (sym.isSynthetic || prev.sym.isSynthetic) {
-            handleSyntheticNameConflict(sym, prev.sym)
-            handleSyntheticNameConflict(prev.sym, sym)
-          }
+          if (settings.debug.value) println("conflict "+sym.name+"#"+sym.id+"#"+prev.sym.id+" "+flagsToString(sym.flags)+" "+flagsToString(prev.sym.flags))
           DoubleDefError(sym, prev.sym)
           sym setInfo ErrorType
           scope unlink prev.sym // let them co-exist...
           // FIXME: The comment "let them co-exist" is confusing given that the
           // line it comments unlinks one of them.  What does it intend?
+          // [Martin] Unlinking does not mean that the symbol goes away.
         }
       }
       scope enter sym
     }

-    /** Logic to handle name conflicts of synthetically generated symbols
-     *  We handle right now: t6227
-     */
-    def handleSyntheticNameConflict(sym1: Symbol, sym2: Symbol) = {
-      if (sym1.isImplicit && sym1.isMethod && sym2.isModule && sym2.companionClass.isCaseClass)
-        validate(sym2.companionClass)
-    }
-
     def enterSym(tree: Tree): Context = {
       def dispatch() = {
         var returnContext = this.context
@@ -251,10 +203,12 @@ trait Namers extends MethodSynthesis {
           case tree @ ValDef(_, _, _, _)                     => enterValDef(tree)
           case tree @ DefDef(_, _, _, _, _, _)               => enterDefDef(tree)
           case tree @ TypeDef(_, _, _, _)                    => enterTypeDef(tree)
-          case DocDef(_, defn)                               => enterSym(defn)
+          case DocDef(doc, defn)                               =>
+            enterSym(defn)
+            context.unit.lateDefs.enterWrapper(defn.symbol, treeCopy.DocDef(tree, doc, _))
           case tree @ Import(_, _)                           =>
             assignSymbol(tree)
-            returnContext = context.make(tree)
+            returnContext = context.makeNewImport(tree)
           case _ =>
         }
         returnContext
@@ -315,15 +269,14 @@ trait Namers extends MethodSynthesis {
         case DefDef(_, nme.CONSTRUCTOR, _, _, _, _) => owner.newConstructor(pos, flags)
         case DefDef(_, _, _, _, _, _)               => owner.newMethod(name.toTermName, pos, flags)
         case ClassDef(_, _, _, _)                   => owner.newClassSymbol(name.toTypeName, pos, flags)
-        case ModuleDef(_, _, _)                     => owner.newModule(name.toTermName, pos, flags)
+        case ModuleDef(_, _, _)                     => owner.newModule(name, pos, flags)
+        case ValDef(_, _, _, _) if isParameter      => owner.newValueParameter(name, pos, flags)
         case PackageDef(pid, _)                     => createPackageSymbol(pos, pid)
-        case ValDef(_, _, _, _)                     =>
-          if (isParameter) owner.newValueParameter(name.toTermName, pos, flags)
-          else owner.newValue(name.toTermName, pos, flags)
+        case ValDef(_, _, _, _)                     => owner.newValue(name, pos, flags)
       }
     }
     private def createFieldSymbol(tree: ValDef): TermSymbol =
-      owner.newValue(tree.localName, tree.pos, tree.mods.flags & FieldFlags | PrivateLocal)
+      owner.newValue(nme.getterToLocal(tree.name), tree.pos, tree.mods.flags & FieldFlags | PrivateLocal)

     private def createImportSymbol(tree: Tree) =
       NoSymbol.newImport(tree.pos) setInfo completerOf(tree)
@@ -331,7 +284,7 @@ trait Namers extends MethodSynthesis {
     /** All PackageClassInfoTypes come from here. */
     private def createPackageSymbol(pos: Position, pid: RefTree): Symbol = {
       val pkgOwner = pid match {
-        case Ident(_)                 => if (owner.isEmptyPackageClass) rootMirror.RootClass else owner
+        case Ident(_)                 => if (owner == EmptyPackageClass) RootClass else owner
         case Select(qual: RefTree, _) => createPackageSymbol(pos, qual).moduleClass
       }
       val existing = pkgOwner.info.decls.lookup(pid.name)
@@ -350,10 +303,11 @@ trait Namers extends MethodSynthesis {
     }

     private def enterClassSymbol(tree: ClassDef, clazz: ClassSymbol): Symbol = {
+      val file = contextFile
       if (clazz.sourceFile != null && clazz.sourceFile != contextFile)
-        devWarning(s"Source file mismatch in $clazz: ${clazz.sourceFile} vs. $contextFile")
+        debugwarn("!!! Source mismatch in " + clazz + ": " + clazz.sourceFile + " vs. " + contextFile)

-      clazz.associatedFile = contextFile
+      clazz.sourceFile = contextFile
       if (clazz.sourceFile != null) {
         assert(currentRun.canRedefine(clazz) || clazz.sourceFile == currentRun.symSource(clazz), clazz.sourceFile)
         currentRun.symSource(clazz) = clazz.sourceFile
@@ -367,7 +321,7 @@ trait Namers extends MethodSynthesis {
       val existing = context.scope.lookup(tree.name)
       val isRedefinition = (
            existing.isType
-        && existing.isTopLevel
+        && existing.owner.isPackageClass
         && context.scope == existing.owner.info.decls
         && currentRun.canRedefine(existing)
       )
@@ -380,37 +334,8 @@ trait Namers extends MethodSynthesis {
         else assignAndEnterSymbol(tree) setFlag inConstructorFlag
       }
       clazz match {
-        case csym: ClassSymbol if csym.isTopLevel => enterClassSymbol(tree, csym)
-        case _                                    => clazz
-      }
-    }
-
-    /** Given a ClassDef or ModuleDef, verifies there isn't a companion which
-     *  has been defined in a separate file.
-     */
-    private def validateCompanionDefs(tree: ImplDef) {
-      val sym = tree.symbol
-      if (sym eq NoSymbol) return
-
-      val ctx    = if (context.owner.isPackageObjectClass) context.outer else context
-      val module = if (sym.isModule) sym else ctx.scope lookupModule tree.name
-      val clazz  = if (sym.isClass) sym else ctx.scope lookupClass tree.name
-      val fails  = (
-           module.isModule
-        && clazz.isClass
-        && !module.isSynthetic
-        && !clazz.isSynthetic
-        && (clazz.sourceFile ne null)
-        && (module.sourceFile ne null)
-        && !(module isCoDefinedWith clazz)
-        && module.exists
-        && clazz.exists
-      )
-      if (fails) {
-        context.unit.error(tree.pos, (
-            s"Companions '$clazz' and '$module' must be defined in same file:\n"
-          + s"  Found in ${clazz.sourceFile.canonicalPath} and ${module.sourceFile.canonicalPath}")
-        )
+        case csym: ClassSymbol if csym.owner.isPackageClass => enterClassSymbol(tree, csym)
+        case _                                              => clazz
       }
     }

@@ -418,21 +343,20 @@ trait Namers extends MethodSynthesis {
       val sym = enterModuleSymbol(tree)
       sym.moduleClass setInfo namerOf(sym).moduleClassTypeCompleter(tree)
       sym setInfo completerOf(tree)
-      validateCompanionDefs(tree)
-      sym
     }

     /** Enter a module symbol. The tree parameter can be either
      *  a module definition or a class definition.
      */
     def enterModuleSymbol(tree : ModuleDef): Symbol = {
-      var m: Symbol = context.scope lookupAll tree.name find (_.isModule) getOrElse NoSymbol
+      var m: Symbol = context.scope.lookup(tree.name)
       val moduleFlags = tree.mods.flags | MODULE
       if (m.isModule && !m.isPackage && inCurrentScope(m) && (currentRun.canRedefine(m) || m.isSynthetic)) {
         updatePosFlags(m, tree.pos, moduleFlags)
         setPrivateWithin(tree, m)
-        m.moduleClass andAlso (setPrivateWithin(tree, _))
-        context.unit.synthetics -= m
+        if (m.moduleClass != NoSymbol)
+          setPrivateWithin(tree, m.moduleClass)
+        context.unit.lateDefs.remove(m)
         tree.symbol = m
       }
       else {
@@ -440,8 +364,8 @@ trait Namers extends MethodSynthesis {
         m.moduleClass setFlag moduleClassFlags(moduleFlags)
         setPrivateWithin(tree, m.moduleClass)
       }
-      if (m.isTopLevel && !m.isPackage) {
-        m.moduleClass.associatedFile = contextFile
+      if (m.owner.isPackageClass && !m.isPackage) {
+        m.moduleClass.sourceFile = contextFile
         currentRun.symSource(m) = m.moduleClass.sourceFile
         registerTopLevelSym(m)
       }
@@ -451,7 +375,6 @@ trait Namers extends MethodSynthesis {
     def enterSyms(trees: List[Tree]): Namer = {
       trees.foldLeft(this: Namer) { (namer, t) =>
         val ctx = namer enterSym t
-        // for Import trees, enterSym returns a changed context, so we need a new namer
         if (ctx eq namer.context) namer
         else newNamer(ctx)
       }
@@ -487,7 +410,7 @@ trait Namers extends MethodSynthesis {
       // The object Foo is still in scope, but because it is not compiled in current run
       // it should be ditched and a new one created.
       if (m != NoSymbol && currentRun.compiles(m)) m
-      else enterSyntheticSym(atPos(cdef.pos.focus)(creator(cdef)))
+      else enterLateDef(atPos(cdef.pos.focus)(creator(cdef)), cdef.symbol)
     }

     private def checkSelectors(tree: Import): Unit = {
@@ -503,9 +426,10 @@ trait Namers extends MethodSynthesis {
             typer.permanentlyHiddenWarning(pos, to0, e.sym)
           else if (context ne context.enclClass) {
             val defSym = context.prefix.member(to) filter (
-              sym => sym.exists && context.isAccessible(sym, context.prefix, superAccess = false))
+              sym => sym.exists && context.isAccessible(sym, context.prefix, false))

-            defSym andAlso (typer.permanentlyHiddenWarning(pos, to0, _))
+            if (defSym != NoSymbol)
+              typer.permanentlyHiddenWarning(pos, to0, defSym)
           }
         }
         if (!tree.symbol.isSynthetic && expr.symbol != null && !expr.symbol.isInterpreterWrapper) {
@@ -522,21 +446,20 @@ trait Namers extends MethodSynthesis {

         if (from != nme.WILDCARD && base != ErrorType) {
           if (isValid(from)) {
+            if (currentRun.compileSourceFor(expr, from)) {
+              // side effecting, apparently
+              typeSig(tree)
+            }
             // for Java code importing Scala objects
-            if (!nme.isModuleName(from) || isValid(from.dropModule)) {
+            else if (!nme.isModuleName(from) || isValid(nme.stripModuleSuffix(from))) {
               typer.TyperErrorGen.NotAMemberError(tree, expr, from)
+              typer.infer.setError(tree)
             }
           }
           // Setting the position at the import means that if there is
           // more than one hidden name, the second will not be warned.
           // So it is the position of the actual hidden name.
-          //
-          // Note: java imports have precence over definitions in the same package
-          //       so don't warn for them. There is a corresponding special treatment
-          //       in the shadowing rules in typedIdent to (SI-7232). In any case,
-          //       we shouldn't be emitting warnings for .java source files.
-          if (!context.unit.isJava)
-            checkNotRedundant(tree.pos withPoint fromPos, from, to)
+          checkNotRedundant(tree.pos withPoint fromPos, from, to)
         }
       }

@@ -556,65 +479,68 @@ trait Namers extends MethodSynthesis {
       noDuplicates(selectors map (_.rename), AppearsTwice)
     }

-    def enterCopyMethod(copyDef: DefDef): Symbol = {
-      val sym      = copyDef.symbol
-      val lazyType = completerOf(copyDef)
-
-      /* Assign the types of the class parameters to the parameters of the
-       * copy method. See comment in `Unapplies.caseClassCopyMeth` */
-      def assignParamTypes() {
-        val clazz = sym.owner
+    def enterCopyMethodOrGetter(tree: Tree, tparams: List[TypeDef]): Symbol = {
+      val sym          = tree.symbol
+      val lazyType     = completerOf(tree, tparams)
+      def completeCopyFirst = sym.isSynthetic && (!sym.hasDefaultFlag || sym.owner.info.member(nme.copy).isSynthetic)
+      def completeCopyMethod(clazz: Symbol) {
+        // the 'copy' method of case classes needs a special type completer to make
+        // bug0054.scala (and others) work. the copy method has to take exactly the same
+        // parameter types as the primary constructor.
         val constructorType = clazz.primaryConstructor.tpe
-        val subst = new SubstSymMap(clazz.typeParams, copyDef.tparams map (_.symbol))
-        val classParamss = constructorType.paramss
-
-        map2(copyDef.vparamss, classParamss)((copyParams, classParams) =>
-          map2(copyParams, classParams)((copyP, classP) =>
-            copyP.tpt setType subst(classP.tpe)
+        val subst           = new SubstSymMap(clazz.typeParams, tparams map (_.symbol))
+        val vparamss        = tree match { case x: DefDef => x.vparamss ; case _ => Nil }
+        val cparamss        = constructorType.paramss
+
+        map2(vparamss, cparamss)((vparams, cparams) =>
+          map2(vparams, cparams)((param, cparam) =>
+            // need to clone the type cparam.tpe???
+            // problem is: we don't have the new owner yet (the new param symbol)
+            param.tpt setType subst(cparam.tpe)
           )
         )
       }
-
       sym setInfo {
-        mkTypeCompleter(copyDef) { sym =>
-          assignParamTypes()
+        mkTypeCompleter(tree) { copySym =>
+          if (completeCopyFirst)
+            completeCopyMethod(copySym.owner)
+
           lazyType complete sym
         }
       }
     }
-
-    def completerOf(tree: Tree): TypeCompleter = {
+    def completerOf(tree: Tree): TypeCompleter = completerOf(tree, treeInfo.typeParameters(tree))
+    def completerOf(tree: Tree, tparams: List[TypeDef]): TypeCompleter = {
       val mono = namerOf(tree.symbol) monoTypeCompleter tree
-      val tparams = treeInfo.typeParameters(tree)
       if (tparams.isEmpty) mono
       else {
-        /* @M! TypeDef's type params are handled differently, e.g., in `type T[A[x <: B], B]`, A and B are entered
-         * first as both are in scope in the definition of x. x is only in scope in `A[x <: B]`.
-         * No symbols are created for the abstract type's params at this point, i.e. the following assertion holds:
-         *     !tree.symbol.isAbstractType || { tparams.forall(_.symbol == NoSymbol)
-         * (tested with the above example, `trait C { type T[A[X <: B], B] }`). See also comment in PolyTypeCompleter.
-         */
+        //@M! TypeDef's type params are handled differently
+        //@M e.g., in [A[x <: B], B], A and B are entered first as both are in scope in the definition of x
+        //@M x is only in scope in `A[x <: B]'
         if (!tree.symbol.isAbstractType) //@M TODO: change to isTypeMember ?
           createNamer(tree) enterSyms tparams

-        new PolyTypeCompleter(tparams, mono, context) //@M
+        new PolyTypeCompleter(tparams, mono, tree, context) //@M
+      }
+    }
+
+    def enterIfNotThere(sym: Symbol) {
+      val scope = context.scope
+      @tailrec def search(e: ScopeEntry) {
+        if ((e eq null) || (e.owner ne scope))
+          scope enter sym
+        else if (e.sym ne sym)  // otherwise, aborts since we found sym
+          search(e.tail)
       }
+      search(scope lookupEntry sym.name)
     }

     def enterValDef(tree: ValDef) {
       if (noEnterGetterSetter(tree))
         assignAndEnterFinishedSymbol(tree)
       else
-        enterGetterSetter(tree)
-
-      // When java enums are read from bytecode, they are known to have
-      // constant types by the jvm flag and assigned accordingly.  When
-      // they are read from source, the java parser marks them with the
-      // STABLE flag, and now we receive that signal.
-      if (tree.symbol hasAllFlags STABLE | JAVA)
-        tree.symbol setInfo ConstantType(Constant(tree.symbol))
+        enterAllValDef(tree)
     }
-
     def enterLazyVal(tree: ValDef, lazyAccessor: Symbol): TermSymbol = {
       // If the owner is not a class, this is a lazy val from a method,
       // with no associated field.  It has an accessor with $lzy appended to its name and
@@ -623,7 +549,7 @@ trait Namers extends MethodSynthesis {
       // via "x$lzy" as can be seen in test #3927.
       val sym = (
         if (owner.isClass) createFieldSymbol(tree)
-        else owner.newValue(tree.name append nme.LAZY_LOCAL, tree.pos, (tree.mods.flags | ARTIFACT) & ~IMPLICIT)
+        else owner.newValue(tree.name append nme.LAZY_LOCAL, tree.pos, tree.mods.flags & ~IMPLICIT)
       )
       enterValSymbol(tree, sym setFlag MUTABLE setLazyAccessor lazyAccessor)
     }
@@ -644,24 +570,31 @@ trait Namers extends MethodSynthesis {
       case DefDef(_, nme.CONSTRUCTOR, _, _, _, _) =>
         assignAndEnterFinishedSymbol(tree)
       case DefDef(mods, name, tparams, _, _, _) =>
-        val bridgeFlag = if (mods hasAnnotationNamed tpnme.bridgeAnnot) BRIDGE | ARTIFACT else 0
+        val bridgeFlag = if (mods hasAnnotationNamed tpnme.bridgeAnnot) BRIDGE else 0
         val sym = assignAndEnterSymbol(tree) setFlag bridgeFlag

-        if (name == nme.copy && sym.isSynthetic)
-          enterCopyMethod(tree)
+        if (name == nme.copy || tree.symbol.name.startsWith(nme.copy + nme.DEFAULT_GETTER_STRING))
+          enterCopyMethodOrGetter(tree, tparams)
         else
-          sym setInfo completerOf(tree)
+          sym setInfo completerOf(tree, tparams)
+
+        if (mods hasFlag MACRO) {
+          if (!(sym.owner.isClass && sym.owner.isStatic))
+            context.error(tree.pos, "macro definition must appear in globally accessible class")
+        }
     }

     def enterClassDef(tree: ClassDef) {
-      val ClassDef(mods, _, _, impl) = tree
-      val primaryConstructorArity = treeInfo.firstConstructorArgs(impl.body).size
+      val ClassDef(mods, name, tparams, impl) = tree
       tree.symbol = enterClassSymbol(tree)
       tree.symbol setInfo completerOf(tree)

       if (mods.isCase) {
+        if (treeInfo.firstConstructorArgs(impl.body).size > MaxFunctionArity)
+          MaxParametersCaseClassError(tree)
+
         val m = ensureCompanionObject(tree, caseModuleDef)
-        m.moduleClass.updateAttachment(new ClassForCaseCompanionAttachment(tree))
+        classOfModuleClass(m.moduleClass) = new WeakReference(tree)
       }
       val hasDefault = impl.body exists {
         case DefDef(_, nme.CONSTRUCTOR, _, vparamss, _, _)  => mexists(vparamss)(_.mods.hasDefault)
@@ -669,10 +602,18 @@ trait Namers extends MethodSynthesis {
       }
       if (hasDefault) {
         val m = ensureCompanionObject(tree)
-        m.updateAttachment(new ConstructorDefaultsAttachment(tree, null))
+        classAndNamerOfModule(m) = (tree, null)
+      }
+      val hasMacro = impl.body exists {
+        case DefDef(mods, _, _, _, _, _) => mods hasFlag MACRO
+        case _                           => false
+      }
+      if (hasMacro) {
+        val m = ensureCompanionObject(tree)
+        classOfModuleClass(m.moduleClass) = new WeakReference(tree)
       }
       val owner = tree.symbol.owner
-      if (settings.lint && owner.isPackageObjectClass && !mods.isImplicit) {
+      if (owner.isPackageObjectClass) {
         context.unit.warning(tree.pos,
           "it is not recommended to define classes/objects inside of package objects.\n" +
           "If possible, define " + tree.symbol + " in " + owner.skipPackageObject + " instead."
@@ -681,79 +622,75 @@ trait Namers extends MethodSynthesis {

       // Suggested location only.
       if (mods.isImplicit) {
-        if (primaryConstructorArity == 1) {
-          log("enter implicit wrapper "+tree+", owner = "+owner)
-          enterImplicitWrapper(tree)
+        println("enter implicit wrapper "+tree+", owner = "+owner)
+        enterImplicitWrapper(tree)
+      }
+    }
+
+    // this logic is needed in case typer was interrupted half
+    // way through and then comes back to do the tree again. In
+    // that case the definitions that were already attributed as
+    // well as any default parameters of such methods need to be
+    // re-entered in the current scope.
+    protected def enterExistingSym(sym: Symbol): Context = {
+      if (forInteractive && sym != null && sym.owner.isTerm) {
+        enterIfNotThere(sym)
+        if (sym.isLazy) {
+          val acc = sym.lazyAccessor
+          if (acc != NoSymbol) enterIfNotThere(acc)
         }
-        else context.unit.error(tree.pos, "implicit classes must accept exactly one primary constructor parameter")
+        defaultParametersOfMethod(sym) foreach enterIfNotThere
       }
-      validateCompanionDefs(tree)
+      this.context
     }

-    // Hooks which are overridden in the presentation compiler
-    def enterExistingSym(sym: Symbol): Context = this.context
-    def enterIfNotThere(sym: Symbol) { }
-
-    def enterSyntheticSym(tree: Tree): Symbol = {
+   def enterLateDef(tree: Tree, original: Symbol = NoSymbol, postProcess: Tree => Tree = identity): Symbol = {
       enterSym(tree)
-      context.unit.synthetics(tree.symbol) = tree
+      context.unit.lateDefs.enterTree(tree, original, postProcess)
+      log("enter late "+tree.symbol+" from "+original)
       tree.symbol
     }

 // --- Lazy Type Assignment --------------------------------------------------

-    def findCyclicalLowerBound(tp: Type): Symbol = {
+    def initializeLowerBounds(tp: Type): Type = {
       tp match {
         case TypeBounds(lo, _) =>
           // check that lower bound is not an F-bound
-          // but carefully: class Foo[T <: Bar[_ >: T]] should be allowed
-          for (tp1 @ TypeRef(_, sym, _) <- lo) {
-            if (settings.breakCycles) {
-              if (!sym.maybeInitialize) {
-                log(s"Cycle inspecting $lo for possible f-bounds: ${sym.fullLocationString}")
-                return sym
-              }
-            }
-            else sym.initialize
-          }
+          for (TypeRef(_, sym, _) <- lo)
+            sym.initialize
         case _ =>
       }
-      NoSymbol
+      tp
     }

     def monoTypeCompleter(tree: Tree) = mkTypeCompleter(tree) { sym =>
-      // this early test is there to avoid infinite baseTypes when
-      // adding setters and getters --> bug798
-      // It is a def in an attempt to provide some insulation against
-      // uninitialized symbols misleading us. It is not a certainty
-      // this accomplishes anything, but performance is a non-consideration
-      // on these flag checks so it can't hurt.
-      def needsCycleCheck = sym.isNonClassType && !sym.isParameter && !sym.isExistential
       logAndValidate(sym) {
-        val tp = typeSig(tree)
-
-        findCyclicalLowerBound(tp) andAlso { sym =>
-          if (needsCycleCheck) {
-            // neg/t1224:  trait C[T] ; trait A { type T >: C[T] <: C[C[T]] }
-            // To avoid an infinite loop on the above, we cannot break all cycles
-            log(s"Reinitializing info of $sym to catch any genuine cycles")
-            sym reset sym.info
-            sym.initialize
-          }
-        }
+        val tp = initializeLowerBounds(typeSig(tree))
         sym setInfo {
           if (sym.isJavaDefined) RestrictJavaArraysMap(tp)
           else tp
         }
-        if (needsCycleCheck) {
-          log(s"Needs cycle check: ${sym.debugLocationString}")
-          if (!typer.checkNonCyclic(tree.pos, tp))
-            sym setInfo ErrorType
-        }
+        // this early test is there to avoid infinite baseTypes when
+        // adding setters and getters --> bug798
+        val needsCycleCheck = (sym.isAliasType || sym.isAbstractType) && !sym.isParameter
+        if (needsCycleCheck && !typer.checkNonCyclic(tree.pos, tp))
+          sym setInfo ErrorType
       }
+      // tree match {
+      //   case ClassDef(_, _, _, impl) =>
+      //     val parentsOK = (
+      //          treeInfo.isInterface(sym, impl.body)
+      //       || (sym eq ArrayClass)
+      //       || (sym isSubClass AnyValClass)
+      //     )
+      //     if (!parentsOK)
+      //       ensureParent(sym, AnyRefClass)
+      //   case _ => ()
+      // }
     }

-    def moduleClassTypeCompleter(tree: ModuleDef) = {
+    def moduleClassTypeCompleter(tree: Tree) = {
       mkTypeCompleter(tree) { sym =>
         val moduleSymbol = tree.symbol
         assert(moduleSymbol.moduleClass == sym, moduleSymbol.moduleClass)
@@ -761,13 +698,13 @@ trait Namers extends MethodSynthesis {
       }
     }

-    /* Explicit isSetter required for bean setters (beanSetterSym.isSetter is false) */
-    def accessorTypeCompleter(tree: ValDef, isSetter: Boolean) = mkTypeCompleter(tree) { sym =>
+    def accessorTypeCompleter(tree: ValDef, isSetter: Boolean = false) = mkTypeCompleter(tree) { sym =>
       logAndValidate(sym) {
         sym setInfo {
-          val tp = if (isSetter) MethodType(List(sym.newSyntheticValueParam(typeSig(tree))), UnitClass.tpe)
-                   else NullaryMethodType(typeSig(tree))
-          pluginsTypeSigAccessor(tp, typer, tree, sym)
+          if (isSetter)
+            MethodType(List(sym.newSyntheticValueParam(typeSig(tree))), UnitClass.tpe)
+          else
+            NullaryMethodType(typeSig(tree))
         }
       }
     }
@@ -808,30 +745,44 @@ trait Namers extends MethodSynthesis {
         case _ =>
           false
       }
-      val shouldWiden = (
-           !tpe.typeSymbolDirect.isModuleClass // Infer Foo.type instead of "object Foo"
-        && (tpe.widen <:< pt)                  // Don't widen our way out of conforming to pt
-        && (   sym.isVariable
-            || sym.isMethod && !sym.hasAccessorFlag
-            || isHidden(tpe)
-           )
-      )
-      dropIllegalStarTypes(
-        if (shouldWiden) tpe.widen
-        else if (sym.isFinal) tpe    // "final val" allowed to retain constant type
-        else tpe.deconst
-      )
+
+      val tpe1 = dropRepeatedParamType(tpe.deconst)
+      val tpe2 = tpe1.widen
+
+      // This infers Foo.type instead of "object Foo"
+      // See Infer#adjustTypeArgs for the polymorphic case.
+      if (tpe.typeSymbolDirect.isModuleClass) tpe1
+      else if (sym.isVariable || sym.isMethod && !sym.hasAccessorFlag)
+        if (tpe2 <:< pt) tpe2 else tpe1
+      else if (isHidden(tpe)) tpe2
+      // In an attempt to make pattern matches involving method local vals
+      // compilable into switches, for a time I had a more generous condition:
+      //    `if (sym.isFinal || sym.isLocal) tpe else tpe1`
+      // This led to issues with expressions like classOf[List[_]] which apparently
+      // depend on being deconst-ed here, so this is again the original:
+      else if (!sym.isFinal) tpe1
+      else tpe
     }
+
     /** Computes the type of the body in a ValDef or DefDef, and
-     *  assigns the type to the tpt's node.  Returns the type.
+     *  assigns the type to the tpt's node. lateDef.enters the definition with the transformed
+     *  rhs for later integration during type checking.
+     *  Returns the type.
      */
-    private def assignTypeToTree(tree: ValOrDefDef, defnTyper: Typer, pt: Type): Type = {
-      val rhsTpe =
-        if (tree.symbol.isTermMacro) defnTyper.computeMacroDefType(tree, pt)
-        else defnTyper.computeType(tree.rhs, pt)
-
-      val defnTpe = widenIfNecessary(tree.symbol, rhsTpe, pt)
-      tree.tpt defineType defnTpe setPos tree.pos.focus
+    private def inferTypeOfTree[T <: ValOrDefDef]
+                               (tree: T, defnTyper: Typer, pt: Type, copier: (Tree, Tree) => Tree): Type = {
+      // compute result type from rhs
+      val (rhs1, rhsType) = defnTyper.packedTyped(tree.rhs, pt)
+      val defnType = widenIfNecessary(if (owner.isMethod) owner else tree.symbol, rhsType, pt)
+      assignTypeToTree(tree, defnType)
+      context.unit.lateDefs.enterWrapper(tree.symbol, copier(_, rhs1))
+      tree.symbol setFlag INFERRED
+      defnType
+      //println("infer: "+tree1)
+    }
+
+    private def assignTypeToTree(tree: ValOrDefDef, tpe: Type): Type = {
+      (tree.tpt defineType tpe) setPos tree.pos.focus
       tree.tpt.tpe
     }

@@ -846,28 +797,35 @@ trait Namers extends MethodSynthesis {
       if (!hasType)
         tpt defineType NoType

+      if (hasType || hasName) {
+        owner.typeOfThis =
+          if (hasType) selfTypeCompleter(tpt)
+          else owner.tpe
+      }
       val sym = (
-        if (hasType || hasName) {
-          owner.typeOfThis = if (hasType) selfTypeCompleter(tpt) else owner.tpe_*
-          val selfSym = owner.thisSym setPos self.pos
-          if (hasName) selfSym setName name else selfSym
-        }
-        else {
-          val symName = if (name != nme.WILDCARD) name else nme.this_
-          owner.newThisSym(symName, owner.pos) setInfo owner.tpe
-        }
+        if (hasType) owner.thisSym setPos self.pos
+        else if (hasName) owner.thisSym
+        else owner.newThisSym(self.pos) setInfo owner.tpe
       )
+      if (hasName)
+        sym.name = name
+
       self.symbol = context.scope enter sym
     }

     private def templateSig(templ: Template): Type = {
       val clazz = context.owner
       def checkParent(tpt: Tree): Type = {
-        if (tpt.tpe.isError) AnyRefClass.tpe
-        else tpt.tpe
+        val tp = tpt.tpe
+        val inheritsSelf = tp.typeSymbol == owner
+        if (inheritsSelf)
+          InheritsItselfError(tpt)
+
+        if (inheritsSelf || tp.isError) AnyRefClass.tpe
+        else tp
       }

-      val parents = typer.typedParentTypes(templ) map checkParent
+      val parents = typer.parentTypes(templ) map checkParent

       enterSelf(templ.self)

@@ -878,25 +836,27 @@ trait Namers extends MethodSynthesis {
       // add apply and unapply methods to companion objects of case classes,
       // unless they exist already; here, "clazz" is the module class
       if (clazz.isModuleClass) {
-        clazz.attachments.get[ClassForCaseCompanionAttachment] foreach { cma =>
-          val cdef = cma.caseClass
-          assert(cdef.mods.isCase, "expected case class: "+ cdef)
-          addApplyUnapply(cdef, templateNamer)
+        NewNamers.this.classOfModuleClass get clazz foreach { cdefRef =>
+          val cdef = cdefRef()
+          if (cdef.mods.isCase) addApplyUnapply(cdef, templateNamer)
+          classOfModuleClass -= clazz
         }
       }

       // add the copy method to case classes; this needs to be done here, not in SyntheticMethods, because
       // the namer phase must traverse this copy method to create default getters for its parameters.
-      // here, clazz is the ClassSymbol of the case class (not the module). (!clazz.hasModuleFlag) excludes
-      // the moduleClass symbol of the companion object when the companion is a "case object".
-      if (clazz.isCaseClass && !clazz.hasModuleFlag) {
+      // here, clazz is the ClassSymbol of the case class (not the module).
+      // @check: this seems to work only if the type completer of the class runs before the one of the
+      // module class: the one from the module class removes the entry from classOfModuleClass (see above).
+      if (clazz.isClass && !clazz.hasModuleFlag) {
         val modClass = companionSymbolOf(clazz, context).moduleClass
-        modClass.attachments.get[ClassForCaseCompanionAttachment] foreach { cma =>
-          val cdef = cma.caseClass
-          def hasCopy = (decls containsName nme.copy) || parents.exists(_ member nme.copy exists)
+        NewNamers.this.classOfModuleClass get modClass map { cdefRef =>
+          val cdef = cdefRef()

-          // SI-5956 needs (cdef.symbol == clazz): there can be multiple class symbols with the same name
-          if (cdef.symbol == clazz && !hasCopy)
+          def hasCopy(decls: Scope) = (decls lookup nme.copy) != NoSymbol
+          if (cdef.mods.isCase && !hasCopy(decls) &&
+                  !parents.exists(p => hasCopy(p.typeSymbol.info.decls)) &&
+                  !parents.flatMap(_.baseClasses).distinct.exists(bc => hasCopy(bc.info.decls)))
             addCopyMethod(cdef, templateNamer)
         }
       }
@@ -904,261 +864,156 @@ trait Namers extends MethodSynthesis {
       // if default getters (for constructor defaults) need to be added to that module, here's the namer
       // to use. clazz is the ModuleClass. sourceModule works also for classes defined in methods.
       val module = clazz.sourceModule
-      for (cda <- module.attachments.get[ConstructorDefaultsAttachment]) {
-        debuglog(s"Storing the template namer in the ConstructorDefaultsAttachment of ${module.debugLocationString}.")
-        cda.companionModuleClassNamer = templateNamer
+      classAndNamerOfModule get module foreach {
+        case (cdef, _) =>
+          classAndNamerOfModule(module) = (cdef, templateNamer)
       }
-      val classTp = ClassInfoType(parents, decls, clazz)
-      pluginsTypeSig(classTp, templateNamer.typer, templ, WildcardType)
+      ClassInfoType(parents, decls, clazz)
     }

-    private def classSig(cdef: ClassDef): Type = {
-      val clazz = cdef.symbol
-      val ClassDef(_, _, tparams, impl) = cdef
+    private def classSig(tparams: List[TypeDef], impl: Template): Type = {
       val tparams0   = typer.reenterTypeParams(tparams)
       val resultType = templateSig(impl)

-      val res = GenPolyType(tparams0, resultType)
-      val pluginsTp = pluginsTypeSig(res, typer, cdef, WildcardType)
-
-      // Already assign the type to the class symbol (monoTypeCompleter will do it again).
-      // Allows isDerivedValueClass to look at the info.
-      clazz setInfo pluginsTp
-      if (clazz.isDerivedValueClass) {
-        log("Ensuring companion for derived value class " + cdef.name + " at " + cdef.pos.show)
-        clazz setFlag FINAL
-        // Don't force the owner's info lest we create cycles as in SI-6357.
-        enclosingNamerWithScope(clazz.owner.rawInfo.decls).ensureCompanionObject(cdef)
-      }
-      pluginsTp
-    }
-
-    private def moduleSig(mdef: ModuleDef): Type = {
-      val moduleSym = mdef.symbol
-      // The info of both the module and the moduleClass symbols need to be assigned. monoTypeCompleter assigns
-      // the result of typeSig to the module symbol. The module class info is assigned here as a side-effect.
-      val result = templateSig(mdef.impl)
-      val pluginsTp = pluginsTypeSig(result, typer, mdef, WildcardType)
-      // Assign the moduleClass info (templateSig returns a ClassInfoType)
-      val clazz = moduleSym.moduleClass
-      clazz setInfo pluginsTp
-      // clazz.tpe_* returns a `ModuleTypeRef(clazz)`, a typeRef that links to the module class `clazz`
-      // (clazz.info would the ClassInfoType, which is not what should be assigned to the module symbol)
-      clazz.tpe_*
+      GenPolyType(tparams0, resultType)
     }

-    /**
-     * The method type for `ddef`.
-     *
-     * If a PolyType(tparams, restp) is returned, `tparams` are the external symbols (not type skolems),
-     * i.e. instances of AbstractTypeSymbol. All references in `restp` to the type parameters are TypeRefs
-     * to these non-skolems.
-     *
-     * For type-checking the rhs (in case the result type is inferred), the type skolems of the type parameters
-     * are entered in scope. Equally, the parameter symbols entered into scope have types which refer to those
-     * skolems: when type-checking the rhs, references to parameters need to have types that refer to the skolems.
-     * In summary, typing an rhs happens with respect to the skolems.
-     *
-     * This means that the method's result type computed by the typer refers to skolems. In order to put it
-     * into the method type (the result of methodSig), typeRefs to skolems have to be replaced by references
-     * to the non-skolems.
-     */
-    private def methodSig(ddef: DefDef): Type = {
-
-      // DEPMETTODO: do we need to skolemize value parameter symbols?
-
-      val DefDef(_, _, tparams, vparamss, tpt, _) = ddef
-
-      val meth = owner
-      val methOwner = meth.owner
-      val site = methOwner.thisType
-
-      /* tparams already have symbols (created in enterDefDef/completerOf), namely the skolemized ones (created
-       * by the PolyTypeCompleter constructor, and assigned to tparams). reenterTypeParams enters the type skolems
-       * into scope and returns the non-skolems.
-       */
+    private def methodSig(ddef: DefDef, mods: Modifiers, tparams: List[TypeDef],
+                          vparamss: List[List[ValDef]], tpt: Tree, rhs: Tree): Type = {
+      val meth  = owner
+      val clazz = meth.owner
+      // enters the skolemized version into scope, returns the deSkolemized symbols
       val tparamSyms = typer.reenterTypeParams(tparams)
-
-      val tparamSkolems = tparams.map(_.symbol)
-
-      /* since the skolemized tparams are in scope, the TypeRefs in types of vparamSymss refer to the type skolems
-       * note that for parameters with missing types, `methodSig` reassigns types of these symbols (the parameter
-       * types from the overridden method).
-       */
+      // since the skolemized tparams are in scope, the TypeRefs in vparamSymss refer to skolemized tparams
       var vparamSymss = enterValueParams(vparamss)

+      // DEPMETTODO: do we need to skolemize value parameter symbols?
+      if (tpt.isEmpty && meth.name == nme.CONSTRUCTOR) {
+        tpt defineType context.enclClass.owner.tpe
+        tpt setPos meth.pos.focus
+      }
+      var resultPt = if (tpt.isEmpty) WildcardType else typer.typedType(tpt).tpe
+      val site = clazz.thisType

-      /*
-       * Creates a method type using tparamSyms and vparamsSymss as argument symbols and `respte` as result type.
-       * All typeRefs to type skolems are replaced by references to the corresponding non-skolem type parameter,
-       * so the resulting type is a valid external method type, it does not contain (references to) skolems.
+      /** Called for all value parameter lists, right to left
+       *  @param vparams the symbols of one parameter list
+       *  @param restpe  the result type (possibly a MethodType)
        */
+      def makeMethodType(vparams: List[Symbol], restpe: Type) = {
+        // TODODEPMET: check that we actually don't need to do anything here
+        // new dependent method types: probably OK already, since 'enterValueParams' above
+        // enters them in scope, and all have a lazy type. so they may depend on other params. but: need to
+        // check that params only depend on ones in earlier sections, not the same. (done by checkDependencies,
+        // so re-use / adapt that)
+        if (owner.isJavaDefined)
+          // TODODEPMET necessary?? new dependent types: replace symbols in restpe with the ones in vparams
+          JavaMethodType(vparams map (p => p setInfo objToAny(p.tpe)), restpe)
+        else
+          MethodType(vparams, restpe)
+      }
+
       def thisMethodType(restpe: Type) = {
         val checkDependencies = new DependentTypeChecker(context)(this)
         checkDependencies check vparamSymss
         // DEPMETTODO: check not needed when they become on by default
         checkDependencies(restpe)

-        val makeMethodType = (vparams: List[Symbol], restpe: Type) => {
-          // TODODEPMET: check that we actually don't need to do anything here
-          // new dependent method types: probably OK already, since 'enterValueParams' above
-          // enters them in scope, and all have a lazy type. so they may depend on other params. but: need to
-          // check that params only depend on ones in earlier sections, not the same. (done by checkDependencies,
-          // so re-use / adapt that)
-          if (meth.isJavaDefined)
-          // TODODEPMET necessary?? new dependent types: replace symbols in restpe with the ones in vparams
-            JavaMethodType(vparams map (p => p setInfo objToAny(p.tpe)), restpe)
-          else
-            MethodType(vparams, restpe)
-        }
-
-
-        val res = GenPolyType(
+        GenPolyType(
           tparamSyms, // deSkolemized symbols  -- TODO: check that their infos don't refer to method args?
           if (vparamSymss.isEmpty) NullaryMethodType(restpe)
           // vparamss refer (if they do) to skolemized tparams
           else (vparamSymss :\ restpe) (makeMethodType)
         )
-        res.substSym(tparamSkolems, tparamSyms)
       }

-      /*
-       * Creates a schematic method type which has WildcardTypes for non specified
-       * return or parameter types. For instance, in `def f[T](a: T, b) = ...`, the
-       * type schema is
-       *
-       *   PolyType(T, MethodType(List(a: T, b: WildcardType), WildcardType))
-       *
-       * where T are non-skolems.
-       */
-      def methodTypeSchema(resTp: Type) = {
-        // for all params without type set WildcaradType
-        mforeach(vparamss)(v => if (v.tpt.isEmpty) v.symbol setInfo WildcardType)
-        thisMethodType(resTp)
-      }
+      def transformedResult =
+        thisMethodType(resultPt).substSym(tparams map (_.symbol), tparamSyms)

-      def overriddenSymbol(resTp: Type) = {
-        intersectionType(methOwner.info.parents).nonPrivateMember(meth.name).filter { sym =>
-          sym != NoSymbol && (site.memberType(sym) matches methodTypeSchema(resTp))
+      // luc: added .substSym from skolemized to deSkolemized
+      // site.memberType(sym): PolyType(tparams, MethodType(..., ...))
+      //    ==> all references to tparams are deSkolemized
+      // thisMethodType: tparams in PolyType are deSkolemized, the references in the MethodTypes are skolemized.
+      //    ==> the two didn't match
+      //
+      // for instance, B.foo would not override A.foo, and the default on parameter b would not be inherited
+      //   class A { def foo[T](a: T)(b: T = a) = a }
+      //   class B extends A { override def foo[U](a: U)(b: U) = b }
+      def overriddenSymbol =
+        intersectionType(clazz.info.parents).nonPrivateMember(meth.name).filter { sym =>
+          sym != NoSymbol && (site.memberType(sym) matches transformedResult)
         }
-      }
-      // TODO: see whether this or something similar would work instead:
+      // TODO: see whether this or something similar would work instead.
+      //
       // def overriddenSymbol = meth.nextOverriddenSymbol

-
-      /*
-       * If `meth` doesn't have an explicit return type, extracts the return type from the method
-       * overridden by `meth` (if there's an unique one). This type is lateron used as the expected
-       * type for computing the type of the rhs. The resulting type references type skolems for
-       * type parameters (consistent with the result of `typer.typedType(tpt).tpe`).
-       *
-       * As a first side effect, this method assigns a MethodType constructed using this
-       * return type to `meth`. This allows omitting the result type for recursive methods.
-       *
-       * As another side effect, this method also assigns paramter types from the overridden
-       * method to parameters of `meth` that have missing types (the parser accepts missing
-       * parameter types under -Yinfer-argument-types).
-       */
-      def typesFromOverridden(methResTp: Type): Type = {
-        val overridden = overriddenSymbol(methResTp)
-        if (overridden == NoSymbol || overridden.isOverloaded) {
-          methResTp
-        } else {
+      // fill in result type and parameter types from overridden symbol if there is a unique one.
+      if (clazz.isClass && (tpt.isEmpty || mexists(vparamss)(_.tpt.isEmpty))) {
+        // try to complete from matching definition in base type
+        mforeach(vparamss)(v => if (v.tpt.isEmpty) v.symbol setInfo WildcardType)
+        val overridden = overriddenSymbol
+        if (overridden != NoSymbol && !overridden.isOverloaded) {
           overridden.cookJavaRawInfo() // #3404 xform java rawtypes into existentials
-          var overriddenTp = site.memberType(overridden) match {
-              case PolyType(tparams, rt) => rt.substSym(tparams, tparamSkolems)
-              case mt => mt
-            }
+          resultPt = site.memberType(overridden) match {
+            case PolyType(tparams, rt) => rt.substSym(tparams, tparamSyms)
+            case mt => mt
+          }
+
           for (vparams <- vparamss) {
-            var overriddenParams = overriddenTp.params
+            var pps = resultPt.params
             for (vparam <- vparams) {
               if (vparam.tpt.isEmpty) {
-                val overriddenParamTp = overriddenParams.head.tpe
-                // references to type parameteres in overriddenParamTp link to the type skolems, so the
-                // assigned type is consistent with the other / existing parameter types in vparamSymss.
-                vparam.symbol setInfo overriddenParamTp
-                vparam.tpt defineType overriddenParamTp setPos vparam.pos.focus
+                val paramtpe = pps.head.tpe
+                vparam.symbol setInfo paramtpe
+                vparam.tpt defineType paramtpe setPos vparam.pos.focus
               }
-              overriddenParams = overriddenParams.tail
+              pps = pps.tail
             }
-            overriddenTp = overriddenTp.resultType
+            resultPt = resultPt.resultType
           }
-
-          overriddenTp match {
-            case NullaryMethodType(rtpe) => overriddenTp = rtpe
-            case MethodType(List(), rtpe) => overriddenTp = rtpe
+          resultPt match {
+            case NullaryMethodType(rtpe) => resultPt = rtpe
+            case MethodType(List(), rtpe) => resultPt = rtpe
             case _ =>
           }
-
           if (tpt.isEmpty) {
             // provisionally assign `meth` a method type with inherited result type
             // that way, we can leave out the result type even if method is recursive.
-            meth setInfo thisMethodType(overriddenTp)
-            overriddenTp
-          } else {
-            methResTp
+            meth setInfo thisMethodType(resultPt)
           }
         }
       }
-
-      if (tpt.isEmpty && meth.name == nme.CONSTRUCTOR) {
-        tpt defineType context.enclClass.owner.tpe_*
-        tpt setPos meth.pos.focus
+      // Add a () parameter section if this overrides some method with () parameters.
+      if (clazz.isClass && vparamss.isEmpty && overriddenSymbol.alternatives.exists(
+        _.info.isInstanceOf[MethodType])) {
+        vparamSymss = List(List())
       }
-
-      val methResTp = if (tpt.isEmpty) WildcardType else typer.typedType(tpt).tpe
-      val resTpFromOverride = if (methOwner.isClass && (tpt.isEmpty || mexists(vparamss)(_.tpt.isEmpty))) {
-          typesFromOverridden(methResTp)
-        } else {
-          methResTp
-        }
-
-      // Add a () parameter section if this overrides some method with () parameters
-      if (methOwner.isClass && vparamss.isEmpty &&
-        overriddenSymbol(methResTp).alternatives.exists(_.info.isInstanceOf[MethodType])) {
-        vparamSymss = ListOfNil
-      }
-
-      // issue an error for missing parameter types
       mforeach(vparamss) { vparam =>
         if (vparam.tpt.isEmpty) {
           MissingParameterOrValTypeError(vparam)
           vparam.tpt defineType ErrorType
         }
       }
+      addDefaultGetters(meth, vparamss, tparams, overriddenSymbol)

-      addDefaultGetters(meth, vparamss, tparams, overriddenSymbol(methResTp))
-
-      // fast track macros, i.e. macros defined inside the compiler, are hardcoded
-      // hence we make use of that and let them have whatever right-hand side they need
-      // (either "macro ???" as they used to or just "???" to maximally simplify their compilation)
-      if (fastTrack contains meth) meth setFlag MACRO
-
-      // macro defs need to be typechecked in advance
-      // because @macroImpl annotation only gets assigned during typechecking
-      // otherwise macro defs wouldn't be able to robustly coexist with their clients
-      // because a client could be typechecked before a macro def that it uses
-      if (meth.isMacro) {
-        typer.computeMacroDefType(ddef, resTpFromOverride)
-      }
-
-      val res = thisMethodType({
+      thisMethodType({
         val rt = (
           if (!tpt.isEmpty) {
-            methResTp
+            typer.typedType(tpt).tpe
+          } else if (meth.isMacro) {
+            assignTypeToTree(ddef, AnyClass.tpe)
           } else {
-            // return type is inferred, we don't just use resTpFromOverride. Here, C.f has type String:
-            //   trait T { def f: Object }; class C <: T { def f = "" }
-            // using resTpFromOverride as expected type allows for the following (C.f has type A):
-            //   trait T { def f: A }; class C <: T { implicit def b2a(t: B): A = ???; def f = new B }
-            assignTypeToTree(ddef, typer, resTpFromOverride)
-          })
+            // replace deSkolemized symbols with skolemized ones
+            // (for resultPt computed by looking at overridden symbol, right?)
+            val pt = resultPt.substSym(tparamSyms, tparams map (_.symbol))
+            inferTypeOfTree(ddef, typer, pt,
+                treeCopy.DefDef(_, ddef.mods, ddef.name, ddef.tparams, ddef.vparamss, ddef.tpt, _))
+          }
+        )
         // #2382: return type of default getters are always @uncheckedVariance
-        if (meth.hasDefault)
+        if (meth.hasDefaultFlag)
           rt.withAnnotation(AnnotationInfo(uncheckedVarianceClass.tpe, List(), List()))
         else rt
       })
-      pluginsTypeSig(res, typer, ddef, methResTp)
     }

     /**
@@ -1170,15 +1025,15 @@ trait Namers extends MethodSynthesis {
      * flag.
      */
     private def addDefaultGetters(meth: Symbol, vparamss: List[List[ValDef]], tparams: List[TypeDef], overriddenSymbol: => Symbol) {
-      val methOwner  = meth.owner
+      val clazz      = meth.owner
       val isConstr   = meth.isConstructor
-      val overridden = if (isConstr || !methOwner.isClass) NoSymbol else overriddenSymbol
+      val overridden = if (isConstr || !clazz.isClass) NoSymbol else overriddenSymbol
       val overrides  = overridden != NoSymbol && !overridden.isOverloaded
       // value parameters of the base class (whose defaults might be overridden)
       var baseParamss = (vparamss, overridden.tpe.paramss) match {
         // match empty and missing parameter list
         case (Nil, List(Nil)) => Nil
-        case (List(Nil), Nil) => ListOfNil
+        case (List(Nil), Nil) => List(Nil)
         case (_, paramss)     => paramss
       }
       assert(
@@ -1205,8 +1060,8 @@ trait Namers extends MethodSynthesis {
         for (vparam <- vparams) {
           val sym = vparam.symbol
           // true if the corresponding parameter of the base class has a default argument
-          val baseHasDefault = overrides && baseParams.head.hasDefault
-          if (sym.hasDefault) {
+          val baseHasDefault = overrides && baseParams.head.hasDefaultFlag
+          if (sym.hasDefaultFlag) {
             // generate a default getter for that argument
             val oflag = if (baseHasDefault) OVERRIDE else 0
             val name = nme.defaultGetterName(meth.name, posCounter)
@@ -1222,21 +1077,16 @@ trait Namers extends MethodSynthesis {

             val parentNamer = if (isConstr) {
               val (cdef, nmr) = moduleNamer.getOrElse {
-                val module = companionSymbolOf(methOwner, context)
+                val module = companionSymbolOf(clazz, context)
                 module.initialize // call type completer (typedTemplate), adds the
                                   // module's templateNamer to classAndNamerOfModule
-                module.attachments.get[ConstructorDefaultsAttachment] match {
-                  // by martin: the null case can happen in IDE; this is really an ugly hack on top of an ugly hack but it seems to work
-                  case Some(cda) =>
-                    if (cda.companionModuleClassNamer == null) {
-                      debugwarn(s"SI-6576 The companion module namer for $meth was unexpectedly null")
-                      return
-                    }
-                    val p = (cda.classWithDefault, cda.companionModuleClassNamer)
-                    moduleNamer = Some(p)
-                    p
+                classAndNamerOfModule get module match {
+                  case s @ Some((cdef, nmr)) if nmr != null =>
+                    moduleNamer = s
+                    (cdef, nmr)
                   case _ =>
                     return // fix #3649 (prevent crash in erroneous source code)
+                           // nmr == null can happen in IDE; this is really an ugly hack on top[ of an ugly hack but it seems to work
                 }
               }
               deftParams = cdef.tparams map copyUntypedInvariant
@@ -1271,12 +1121,16 @@ trait Namers extends MethodSynthesis {
                 name, deftParams, defvParamss, defTpt, defRhs)
             }
             if (!isConstr)
-              methOwner.resetFlag(INTERFACE) // there's a concrete member now
-            val default = parentNamer.enterSyntheticSym(defaultTree)
-            if (default.owner.isTerm)
-              saveDefaultGetter(meth, default)
-          }
-          else if (baseHasDefault) {
+              clazz.resetFlag(INTERFACE) // there's a concrete member now
+            val default = parentNamer.enterLateDef(defaultTree, meth)
+            if (forInteractive && default.owner.isTerm) {
+              // enter into map from method symbols to default arguments.
+              // if compiling the same local block several times (which can happen in interactive mode)
+              // we might otherwise not find the default symbol, because the second time it the
+              // method symbol will be re-entered in the scope but the default parameter will not.
+              defaultParametersOfMethod(meth) += default
+            }
+          } else if (baseHasDefault) {
             // the parameter does not have a default itself, but the
             // corresponding parameter in the base class does.
             sym.setFlag(DEFAULTPARAM)
@@ -1289,31 +1143,15 @@ trait Namers extends MethodSynthesis {
       }
     }

-    private def valDefSig(vdef: ValDef) = {
-      val ValDef(_, _, tpt, rhs) = vdef
-      val result = if (tpt.isEmpty) {
-        if (rhs.isEmpty) {
-          MissingParameterOrValTypeError(tpt)
-          ErrorType
-        }
-        else assignTypeToTree(vdef, typer, WildcardType)
-      } else {
-        typer.typedType(tpt).tpe
-      }
-      pluginsTypeSig(result, typer, vdef, if (tpt.isEmpty) WildcardType else result)
-
-    }
-
     //@M! an abstract type definition (abstract type member/type parameter)
     // may take type parameters, which are in scope in its bounds
-    private def typeDefSig(tdef: TypeDef) = {
-      val TypeDef(_, _, tparams, rhs) = tdef
+    private def typeDefSig(tpsym: Symbol, tparams: List[TypeDef], rhs: Tree) = {
       // log("typeDefSig(" + tpsym + ", " + tparams + ")")
       val tparamSyms = typer.reenterTypeParams(tparams) //@M make tparams available in scope (just for this abstypedef)
       val tp = typer.typedType(rhs).tpe match {
         case TypeBounds(lt, rt) if (lt.isError || rt.isError) =>
           TypeBounds.empty
-        case tp @ TypeBounds(lt, rt) if (tdef.symbol hasFlag JAVA) =>
+        case tp @ TypeBounds(lt, rt) if (tpsym hasFlag JAVA) =>
           TypeBounds(lt, objToAny(rt))
         case tp =>
           tp
@@ -1335,34 +1173,9 @@ trait Namers extends MethodSynthesis {
       // However, separate compilation requires the symbol info to be
       // loaded to do this check, but loading the info will probably
       // lead to spurious cyclic errors.  So omit the check.
-      val res = GenPolyType(tparamSyms, tp)
-      pluginsTypeSig(res, typer, tdef, WildcardType)
-    }
-
-    private def importSig(imp: Import) = {
-      val Import(expr, selectors) = imp
-      val expr1 = typer.typedQualifier(expr)
-
-      if (expr1.symbol != null && expr1.symbol.isRootPackage)
-        RootImportError(imp)
-
-      if (expr1.isErrorTyped)
-        ErrorType
-      else {
-        if (!treeInfo.isStableIdentifierPattern(expr1))
-          typer.TyperErrorGen.UnstableTreeError(expr1)
-
-        val newImport = treeCopy.Import(imp, expr1, selectors).asInstanceOf[Import]
-        checkSelectors(newImport)
-        transformed(imp) = newImport
-        // copy symbol and type attributes back into old expression
-        // so that the structure builder will find it.
-        expr setSymbol expr1.symbol setType expr1.tpe
-        ImportType(expr1)
-      }
+      GenPolyType(tparamSyms, tp)
     }

-
     /** Given a case class
      *   case class C[Ts] (ps: Us)
      *  Add the following methods to toScope:
@@ -1377,30 +1190,23 @@ trait Namers extends MethodSynthesis {
      */
     def addApplyUnapply(cdef: ClassDef, namer: Namer) {
       if (!cdef.symbol.hasAbstractFlag)
-        namer.enterSyntheticSym(caseModuleApplyMeth(cdef))
+        namer.enterLateDef(caseModuleApplyMeth(cdef))

-      val primaryConstructorArity = treeInfo.firstConstructorArgs(cdef.impl.body).size
-      if (primaryConstructorArity <= MaxTupleArity)
-        namer.enterSyntheticSym(caseModuleUnapplyMeth(cdef))
+      namer.enterLateDef(caseModuleUnapplyMeth(cdef))
     }

     def addCopyMethod(cdef: ClassDef, namer: Namer) {
-      caseClassCopyMeth(cdef) foreach namer.enterSyntheticSym
+      caseClassCopyMeth(cdef) foreach (namer.enterLateDef(_))
     }

-    /**
-     * TypeSig is invoked by monoTypeCompleters. It returns the type of a definition which
-     * is then assigned to the corresponding symbol (typeSig itself does not need to assign
-     * the type to the symbol, but it can if necessary).
-     */
     def typeSig(tree: Tree): Type = {
       // log("typeSig " + tree)
-      /* For definitions, transform Annotation trees to AnnotationInfos, assign
-       * them to the sym's annotations. Type annotations: see Typer.typedAnnotated
-       * We have to parse definition annotations here (not in the typer when traversing
-       * the MemberDef tree): the typer looks at annotations of certain symbols; if
-       * they were added only in typer, depending on the compilation order, they may
-       * or may not be visible.
+      /** For definitions, transform Annotation trees to AnnotationInfos, assign
+       *  them to the sym's annotations. Type annotations: see Typer.typedAnnotated
+       *  We have to parse definition annotations here (not in the typer when traversing
+       *  the MemberDef tree): the typer looks at annotations of certain symbols; if
+       *  they were added only in typer, depending on the compilation order, they may
+       *  or may not be visible.
        */
       def annotate(annotated: Symbol) = {
         // typeSig might be called multiple times, e.g. on a ValDef: val, getter, setter
@@ -1408,12 +1214,8 @@ trait Namers extends MethodSynthesis {
         if (!annotated.isInitialized) tree match {
           case defn: MemberDef =>
             val ainfos = defn.mods.annotations filterNot (_ eq null) map { ann =>
-              // need to be lazy, #1782. beforeTyper to allow inferView in annotation args, SI-5892.
-              AnnotationInfo lazily {
-                val context1 = typer.context.make(ann)
-                context1.setReportErrors()
-                enteringTyper(newTyper(context1) typedAnnotation ann)
-              }
+              // need to be lazy, #1782
+              AnnotationInfo lazily (typer typedAnnotation ann)
             }
             if (ainfos.nonEmpty) {
               annotated setAnnotations ainfos
@@ -1425,33 +1227,80 @@ trait Namers extends MethodSynthesis {
       }

       val sym: Symbol = tree.symbol
-
-      // TODO: meta-annotations to indicate where module annotations should go (module vs moduleClass)
+      // @Lukas: I am not sure this is the right way to do things.
+      // We used to only decorate the module class with annotations, which is
+      // clearly wrong. Now we decorate both the class and the object.
+      // But maybe some annotations are only meant for one of these but not for the other?
+      //
+      // TODO: meta-annotations to indicate class vs. object.
       annotate(sym)
       if (sym.isModule) annotate(sym.moduleClass)

       def getSig = tree match {
-        case cdef: ClassDef =>
-          createNamer(tree).classSig(cdef)
+        case cdef @ ClassDef(_, name, tparams, impl) =>
+          val clazz = tree.symbol
+          val result = createNamer(tree).classSig(tparams, impl)
+          clazz setInfo result
+          if (clazz.isDerivedValueClass) {
+            log("Ensuring companion for derived value class " + name + " at " + cdef.pos.show)
+            clazz setFlag FINAL
+            enclosingNamerWithScope(clazz.owner.info.decls).ensureCompanionObject(cdef)
+          }
+          result
+
+        case ModuleDef(_, _, impl) =>
+          val clazz = sym.moduleClass
+          clazz setInfo createNamer(tree).templateSig(impl)
+          clazz.tpe
+
+        case ddef @ DefDef(mods, _, tparams, vparamss, tpt, rhs) =>
+          // TODO: cleanup parameter list
+          createNamer(tree).methodSig(ddef, mods, tparams, vparamss, tpt, rhs)
+
+        case vdef @ ValDef(mods, name, tpt, rhs) =>
+          val isBeforeSupercall = (
+               (sym hasFlag PARAM | PRESUPER)
+            && !mods.isJavaDefined
+            && sym.owner.isConstructor
+          )
+          val typer1 = typer.constrTyperIf(isBeforeSupercall)
+          if (tpt.isEmpty) {
+            if (rhs.isEmpty) {
+              MissingParameterOrValTypeError(tpt)
+              ErrorType
+            }
+            else inferTypeOfTree(vdef, newTyper(typer1.context.make(vdef, sym)), WildcardType,
+                treeCopy.ValDef(_, vdef.mods, vdef.name, vdef.tpt, _))
+          }
+          else typer1.typedType(tpt).tpe

-        case mdef: ModuleDef =>
-          createNamer(tree).moduleSig(mdef)
+        case TypeDef(_, _, tparams, rhs) =>
+          createNamer(tree).typeDefSig(sym, tparams, rhs) //@M!

-        case ddef: DefDef =>
-          createNamer(tree).methodSig(ddef)
+        case Import(expr, selectors) =>
+          val expr1 = typer.typedQualifier(expr)
+          typer checkStable expr1
+          if (expr1.symbol != null && expr1.symbol.isRootPackage)
+            RootImportError(tree)

-        case vdef: ValDef =>
-          createNamer(tree).valDefSig(vdef)
+          val newImport = treeCopy.Import(tree, expr1, selectors)
+          checkSelectors(newImport)
+          context.unit.lateDefs.enterTree(newImport)
+          // copy symbol and type attributes back into old expression
+          // so that the structure builder will find it.
+          expr.symbol = expr1.symbol
+          expr.tpe = expr1.tpe
+          ImportType(expr1)
+      }

-        case tdef: TypeDef =>
-          createNamer(tree).typeDefSig(tdef) //@M!
+      val result =
+        try getSig
+        catch typeErrorHandler(tree, ErrorType)

-        case imp: Import =>
-          importSig(imp)
+      result match {
+        case PolyType(tparams @ (tp :: _), _) if tp.owner.isTerm => deskolemizeTypeParams(tparams)(result)
+        case _                                                   => result
       }
-
-      try getSig
-      catch typeErrorHandler(tree, ErrorType)
     }

     def includeParent(tpe: Type, parent: Symbol): Type = tpe match {
@@ -1464,6 +1313,12 @@ trait Namers extends MethodSynthesis {
         tpe
     }

+    def ensureParent(clazz: Symbol, parent: Symbol) = {
+      val info0 = clazz.info
+      val info1 = includeParent(info0, parent)
+      if (info0 ne info1) clazz setInfo info1
+    }
+
     class LogTransitions[S](onEnter: S => String, onExit: S => String) {
       val enabled = settings.debug.value
       @inline final def apply[T](entity: S)(body: => T): T = {
@@ -1473,7 +1328,7 @@ trait Namers extends MethodSynthesis {
       }
     }
     private val logDefinition = new LogTransitions[Symbol](
-      sym => "[define] >> " + sym.flagString + " " + sym.fullLocationString,
+      sym => "[define] >> " + sym.defaultFlagString + " " + sym.fullLocationString,
       sym => "[define] << " + sym
     )
     private def logAndValidate(sym: Symbol)(body: => Unit) {
@@ -1484,11 +1339,6 @@ trait Namers extends MethodSynthesis {
     /** Convert Java generic array type T[] to (T with Object)[]
      *  (this is necessary because such arrays have a representation which is incompatible
      *   with arrays of primitive types.)
-     *
-     *  @note the comparison to Object only works for abstract types bounded by classes that are strict subclasses of Object
-     *  if the bound is exactly Object, it will have been converted to Any, and the comparison will fail
-     *
-     *  see also sigToType
      */
     private object RestrictJavaArraysMap extends TypeMap {
       def apply(tp: Type): Type = tp match {
@@ -1524,11 +1374,10 @@ trait Namers extends MethodSynthesis {
           fail(ImplicitConstr)
         if (!(sym.isTerm || (sym.isClass && !sym.isTrait)))
           fail(ImplicitNotTermOrClass)
-        if (sym.isTopLevel)
+        if (sym.owner.isPackageClass)
           fail(ImplicitAtToplevel)
       }
       if (sym.isClass) {
-        checkNoConflict(IMPLICIT, CASE)
         if (sym.isAnyOverride && !sym.hasFlag(TRAIT))
           fail(OverrideClass)
       } else {
@@ -1540,18 +1389,12 @@ trait Namers extends MethodSynthesis {

       if (sym.isConstructor && sym.isAnyOverride)
         fail(OverrideConstr)
-      if (sym.isAbstractOverride) {
-          if (!sym.owner.isTrait)
-            fail(AbstractOverride)
-          if(sym.isType)
-            fail(AbstractOverrideOnTypeMember)
-      }
+      if (sym.isAbstractOverride && !sym.owner.isTrait)
+        fail(AbstractOverride)
       if (sym.isLazy && sym.hasFlag(PRESUPER))
         fail(LazyAndEarlyInit)
       if (sym.info.typeSymbol == FunctionClass(0) && sym.isValueParameter && sym.owner.isCaseClass)
         fail(ByNameParameter)
-      if (sym.isTrait && sym.isFinal && !sym.isSubClass(AnyValClass))
-        checkNoConflict(ABSTRACT, FINAL)

       if (sym.isDeferred) {
         // Is this symbol type always allowed the deferred flag?
@@ -1584,113 +1427,8 @@ trait Namers extends MethodSynthesis {
       // converted to ABSOVERRIDE before arriving here.
       checkNoConflict(ABSTRACT, OVERRIDE)
     }
-  }
-
-  abstract class TypeCompleter extends LazyType {
-    val tree: Tree
-  }
-
-  def mkTypeCompleter(t: Tree)(c: Symbol => Unit) = new LockingTypeCompleter {
-    val tree = t
-    def completeImpl(sym: Symbol) = c(sym)
-  }
-
-  trait LockingTypeCompleter extends TypeCompleter {
-    def completeImpl(sym: Symbol): Unit
-
-    override def complete(sym: Symbol) = {
-      _lockedCount += 1
-      try completeImpl(sym)
-      finally _lockedCount -= 1
-    }
-  }
-
-  /**
-   * A class representing a lazy type with known type parameters. `ctx` is the namer context in which the
-   * `owner` is defined.
-   *
-   * Constructing a PolyTypeCompleter for a DefDef creates type skolems for the type parameters and
-   * assigns them to the `tparams` trees.
-   */
-  class PolyTypeCompleter(tparams: List[TypeDef], restp: TypeCompleter, ctx: Context) extends LockingTypeCompleter with FlagAgnosticCompleter {
-    // @M. If `owner` is an abstract type member, `typeParams` are all NoSymbol (see comment in `completerOf`),
-    // otherwise, the non-skolemized (external) type parameter symbols
-    override val typeParams = tparams map (_.symbol)
-
-    /* The definition tree (poly ClassDef, poly DefDef or HK TypeDef) */
-    override val tree = restp.tree
-
-    private val defnSym = tree.symbol
-
-    if (defnSym.isTerm) {
-      // for polymorphic DefDefs, create type skolems and assign them to the tparam trees.
-      val skolems = deriveFreshSkolems(tparams map (_.symbol))
-      map2(tparams, skolems)(_ setSymbol _)
-    }

-    def completeImpl(sym: Symbol) = {
-      // @M an abstract type's type parameters are entered.
-      // TODO: change to isTypeMember ?
-      if (defnSym.isAbstractType)
-        newNamer(ctx.makeNewScope(tree, tree.symbol)) enterSyms tparams //@M
-      restp complete sym
-    }
-  }
+    def addDerivedTrees(typer: Typer, stat: Tree): List[Tree] = List(stat) /* not needed */

-  // Can we relax these restrictions? For motivation, see
-  //    test/files/pos/depmet_implicit_oopsla_session_2.scala
-  //    neg/depmet_try_implicit.scala
-  //
-  // We should allow forward references since type selections on
-  // implicit args are like type parameters.
-  //    def foo[T](a: T, x: w.T2)(implicit w: ComputeT2[T])
-  // is more compact than:
-  //    def foo[T, T2](a: T, x: T2)(implicit w: ComputeT2[T, T2])
-  // moreover, the latter is not an encoding of the former, which hides type
-  // inference of T2, so you can specify T while T2 is purely computed
-  private class DependentTypeChecker(ctx: Context)(namer: Namer) extends TypeTraverser {
-    private[this] val okParams = mutable.Set[Symbol]()
-    private[this] val method   = ctx.owner
-
-    def traverse(tp: Type) = tp match {
-      case SingleType(_, sym) =>
-        if (sym.owner == method && sym.isValueParameter && !okParams(sym))
-          namer.NamerErrorGen.IllegalDependentMethTpeError(sym)(ctx)
-
-      case _ => mapOver(tp)
-    }
-    def check(vparamss: List[List[Symbol]]) {
-      for (vps <- vparamss) {
-        for (p <- vps)
-          this(p.info)
-        // can only refer to symbols in earlier parameter sections
-        // (if the extension is enabled)
-        okParams ++= vps
-      }
-    }
-  }
-
-  @deprecated("Use underlyingSymbol instead", "2.10.0")
-  def underlying(member: Symbol): Symbol = underlyingSymbol(member)
-  @deprecated("Use `companionSymbolOf` instead", "2.10.0")
-  def companionClassOf(module: Symbol, ctx: Context): Symbol = companionSymbolOf(module, ctx)
-  @deprecated("Use `companionSymbolOf` instead", "2.10.0")
-  def companionModuleOf(clazz: Symbol, ctx: Context): Symbol = companionSymbolOf(clazz, ctx)
-
-  /** The companion class or companion module of `original`.
-   *  Calling .companionModule does not work for classes defined inside methods.
-   *
-   *  !!! Then why don't we fix companionModule? Does the presence of these
-   *  methods imply all the places in the compiler calling sym.companionModule are
-   *  bugs waiting to be reported? If not, why not? When exactly do we need to
-   *  call this method?
-   */
-  def companionSymbolOf(original: Symbol, ctx: Context): Symbol = {
-    original.companionSymbol orElse {
-      ctx.lookup(original.name.companionName, original.owner).suchThat(sym =>
-        (original.isTerm || sym.hasModuleFlag) &&
-        (sym isCoDefinedWith original)
-      )
-    }
   }
 }
diff --git c/src/compiler/scala/tools/nsc/typechecker/SuperAccessors.scala w/src/compiler/scala/tools/nsc/typechecker/SuperAccessors.scala
index 4e78cecd7d..622f2296ac 100644
--- c/src/compiler/scala/tools/nsc/typechecker/SuperAccessors.scala
+++ w/src/compiler/scala/tools/nsc/typechecker/SuperAccessors.scala
@@ -139,7 +139,8 @@ abstract class SuperAccessors extends transform.Transform with transform.TypingT
     override def transform(tree: Tree): Tree = {
       val sym = tree.symbol

-      def mayNeedProtectedAccessor(sel: Select, args: List[Tree], goToSuper: Boolean) =
+      def mayNeedProtectedAccessor(sel: Select, args: List[Tree], goToSuper: Boolean) = {
+        if (sym == NoSymbol) println("!!!NOSYM!!!" + tree)
         if (needsProtectedAccessor(sym, tree.pos)) {
           debuglog("Adding protected accessor for " + tree)

@@ -147,6 +148,7 @@ abstract class SuperAccessors extends transform.Transform with transform.TypingT
         }
         else if (goToSuper) super.transform(tree)
         else tree
+      }

       try tree match {
         // Don't transform patterns or strange trees will reach the matcher (ticket #4062)
@@ -236,7 +238,6 @@ abstract class SuperAccessors extends transform.Transform with transform.TypingT
                 }
               }

-
               def isAccessibleFromSuper(sym: Symbol) = {
                 val pre = SuperType(sym.owner.tpe, qual.tpe)
                 localTyper.context.isAccessible(sym, pre, superAccess = true)
diff --git c/src/compiler/scala/tools/nsc/typechecker/Typers.scala w/src/compiler/scala/tools/nsc/typechecker/Typers.scala
index 1845c8ed66..0e1d84a7ab 100644
--- c/src/compiler/scala/tools/nsc/typechecker/Typers.scala
+++ w/src/compiler/scala/tools/nsc/typechecker/Typers.scala
@@ -40,7 +40,8 @@ trait Typers extends Adaptations with Tags {
   // namer calls typer.computeType(rhs) on DefDef / ValDef when tpt is empty. the result
   // is cached here and re-used in typedDefDef / typedValDef
   // Also used to cache imports type-checked by namer.
-  val transformed = new mutable.HashMap[Tree, Tree]
+  // Used only if -Yxnamer is not set
+  // val transformed = new mutable.HashMap[Tree, Tree]

   final val shortenImports = false

@@ -2074,7 +2075,7 @@ trait Typers extends Adaptations with Tags {
             LocalVarUninitializedError(vdef)
           vdef.rhs
         } else {
-          val tpt2 = if (sym.hasDefault) {
+          val pt1 = if (sym.hasDefault) {
             // When typechecking default parameter, replace all type parameters in the expected type by Wildcard.
             // This allows defining "def foo[T](a: T = 1)"
             val tparams = sym.owner.skipConstructor.info.typeParams
@@ -2090,7 +2091,8 @@ trait Typers extends Adaptations with Tags {
               else subst(tpt1.tpe.typeArgs(0))
             else subst(tpt1.tpe)
           } else tpt1.tpe
-          transformedOrTyped(vdef.rhs, EXPRmode | BYVALmode, tpt2)
+          /* TODO: newTyper(typer1.context.make(vdef, sym)).*/
+          typedRhs(vdef.rhs, EXPRmode | BYVALmode, tpt2)
         }
       treeCopy.ValDef(vdef, typedMods, vdef.name, tpt1, checkDead(rhs1)) setType NoType
     }
@@ -2299,7 +2301,7 @@ trait Typers extends Adaptations with Tags {
           // that's why we employ our custom typing scheme orchestrated outside of the typer
           transformedOr(ddef.rhs, typedMacroBody(this, ddef))
         } else {
-          transformedOrTyped(ddef.rhs, EXPRmode, tpt1.tpe)
+          typedRhs(ddef, EXPRmode, tpt1.tpe)
         }

       if (meth.isClassConstructor && !isPastTyper && !meth.owner.isSubClass(AnyValClass)) {
@@ -2876,13 +2878,11 @@ trait Typers extends Adaptations with Tags {
       }
     }

-    def typedImport(imp : Import) : Import = (transformed remove imp) match {
-      case Some(imp1: Import) => imp1
-      case _                  => log("unhandled import: "+imp+" in "+unit); imp
-    }
+    def typedImport(imp : Import) : Import = imp

     def typedStats(stats: List[Tree], exprOwner: Symbol): List[Tree] = {
       val inBlock = exprOwner == context.owner
+      val scope = if (inBlock) context.scope else context.owner.info.decls
       def includesTargetPos(tree: Tree) =
         tree.pos.isRange && context.unit.exists && (tree.pos includes context.unit.targetPos)
       val localTarget = stats exists includesTargetPos
@@ -2897,6 +2897,11 @@ trait Typers extends Adaptations with Tags {
                 context = context.make(imp)
                 typedImport(imp)
               } else EmptyTree
+            case ValDef(mods, name, tpt, rhs) if (stat.symbol.flags & PrivateLocal) != (mods.flags & PrivateLocal) =>
+              // todo: make field generation enterLate the new node.
+              //  once getters and setters are under the new scheme this case can be removed.
+              typedStat(treeCopy.ValDef(
+                stat, mods &~ PrivateLocal | (stat.symbol.flags & PrivateLocal), stat.symbol.name, tpt, rhs))
             case _ =>
               if (localTarget && !includesTargetPos(stat)) {
                 // skip typechecking of statements in a sequence where some other statement includes
@@ -2925,16 +2930,11 @@ trait Typers extends Adaptations with Tags {
           }
       }

-      /* 'accessor' and 'accessed' are so similar it becomes very difficult to
-       * follow the logic, so I renamed one to something distinct.
-       */
-      def accesses(looker: Symbol, accessed: Symbol) = accessed.hasLocalFlag && (
+      def checkNoDoubleDefs(): Unit = {
+        def accesses(looker: Symbol, accessed: Symbol) = accessed.hasLocalFlag && (
            (accessed.isParamAccessor)
-        || (looker.hasAccessorFlag && !accessed.hasAccessorFlag && accessed.isPrivate)
-      )
-
-      def checkNoDoubleDefs(stats: List[Tree]): Unit = {
-        val scope = if (inBlock) context.scope else context.owner.info.decls
+           || (looker.hasAccessorFlag && !accessed.hasAccessorFlag && accessed.isPrivate)
+        )
         var e = scope.elems
         while ((e ne null) && e.owner == scope) {
           var e1 = scope.lookupNextEntry(e)
@@ -2958,25 +2958,47 @@ trait Typers extends Adaptations with Tags {
         }
       }

-      def addSynthetics(stats: List[Tree]): List[Tree] = {
-        val scope = if (inBlock) context.scope else context.owner.info.decls
-        var newStats = new ListBuffer[Tree]
+      val newStats = new ListBuffer[Tree]
+
+      def processStat(sym: Symbol, oldstat: Tree = EmptyTree): Unit = {
+        sym.initialize
+        val (latedef, dependent) = context.unit.lateDefs.remove(sym)
+        val newstat = latedef trans oldstat
+        if (newstat != EmptyTree) {
+          log("processStat "+(if (newstat == oldstat) "old " else "new ")+sym+" "+newstat)
+          newStats += typedStat(newstat)
+        }
+        for (dep <- dependent) processStat(dep)
+      }
+
+      for (stat <- stats) {
+        processStat(if (stat.isDef || stat.isInstanceOf[Import]) stat.symbol else NoSymbol, stat)
+      }
+
+      if (!phase.erasedTypes && !context.owner.isPackageClass) {
+        // there are two reasons for excluding package members from
+        // double def checking and sythetics generation
+        // (1) since package scopes tend to be large, this could speed up things
+        // (2) package members can be visited many times during type checking
+        // This means that a companion object might be inserted far form its companion
+        // class by travsering synthetic late bound members. But we want to
+        // wait for the companion class to be generated so that the companion object
+        // is generated next to it.
+        checkNoDoubleDefs()
         var moreToAdd = true
         while (moreToAdd) {
           val initElems = scope.elems
+
           // SI-5877 The decls of a package include decls of the package object. But we don't want to add
           //         the corresponding synthetics to the package class, only to the package object class.
           def shouldAdd(sym: Symbol) =
             inBlock || !context.isInPackageObject(sym, context.owner)
-          for (sym <- scope if shouldAdd(sym))
-            for (tree <- context.unit.synthetics get sym) {
-              newStats += typedStat(tree) // might add even more synthetics to the scope
-              context.unit.synthetics -= sym
-            }
+          for (sym <- scope if shouldAdd(sym)) processStat(sym)
           // the type completer of a synthetic might add more synthetics. example: if the
           // factory method of a case class (i.e. the constructor) has a default.
           moreToAdd = scope.elems ne initElems
         }
+
         if (newStats.isEmpty) stats
         else {
           // put default getters next to the method they belong to,
@@ -3012,12 +3034,29 @@ trait Typers extends Adaptations with Tags {
         }
       }

+      // Expand late definitions that correspond to one of the existing statements in stats
+      // But take care not to copy stat trees unless necesary.
+      val stats0 = {
+        var changed = false
+        def expandStat(stat: Tree): List[Tree] =
+          context.unit.lateDefs get stat.symbol match {
+            case Some(newstats) if stat.isDef =>
+              changed = true
+              context.unit.lateDefs -= stat.symbol
+              newstats
+            case _ => List(stat)
+          }
+        val newstats = stats flatMap expandStat
+        if (changed) newstats else stats
+      }
+
       val stats1 = stats mapConserve typedStat
       if (phase.erasedTypes) stats1
       else {
         checkNoDoubleDefs(stats1)
         addSynthetics(stats1)
       }
+      if (stats == newStats) stats else newStats.toList
     }

     def typedArg(arg: Tree, mode: Mode, newmode: Mode, pt: Type): Tree = {
@@ -5504,6 +5543,12 @@ trait Typers extends Adaptations with Tags {

     def typedTypeConstructor(tree: Tree): Tree = typedTypeConstructor(tree, NOmode)

+    def packedTyped(tree: Tree, pt: Type): (Tree, Type) = {
+      var tree1 = typed(tree, pt)
+      val tpe = packedType(tree1, context.owner)
+      (tree1, tpe)
+    }
+/*
     def computeType(tree: Tree, pt: Type): Type = {
       // macros employ different logic of `computeType`
       assert(!context.owner.isMacro, context.owner)
@@ -5531,6 +5576,11 @@ trait Typers extends Adaptations with Tags {
           transformed(ddef.rhs) = tree1
           tree1
         }
+    }
+*/
+    def typedRhs(tree: ValOrDefDef, mode: Int, pt: Type): Tree =
+      if (tree.symbol hasFlag INFERRED) { tree.symbol resetFlag INFERRED; tree.rhs }
+      else typed(tree.rhs, mode, pt)

       val isMacroBodyOkay = !tree.symbol.isErroneous && !(tree1 exists (_.isErroneous)) && tree1 != EmptyTree
       val shouldInheritMacroImplReturnType = ddef.tpt.isEmpty
diff --git c/src/interactive/scala/tools/nsc/interactive/Global.scala w/src/interactive/scala/tools/nsc/interactive/Global.scala
index 6a833ab864..2ec4f44dd8 100644
--- c/src/interactive/scala/tools/nsc/interactive/Global.scala
+++ w/src/interactive/scala/tools/nsc/interactive/Global.scala
@@ -605,7 +605,7 @@ class Global(settings: Settings, _reporter: Reporter, projectName: String = "")
   private def reset(unit: RichCompilationUnit): Unit = {
     unit.depends.clear()
     unit.defined.clear()
-    unit.synthetics.clear()
+    unit.lateDefs.clear()
     unit.toCheck.clear()
     unit.checkedFeatures = Set()
     unit.targetPos = NoPosition
diff --git c/src/reflect/scala/reflect/internal/Flags.scala w/src/reflect/scala/reflect/internal/Flags.scala
index b8e3407824..102b94d04e 100644
--- c/src/reflect/scala/reflect/internal/Flags.scala
+++ w/src/reflect/scala/reflect/internal/Flags.scala
@@ -63,7 +63,7 @@ import scala.collection.{ mutable, immutable }
 // 45:  SYNCHRONIZED/M
 // 46:        ARTIFACT
 // 47: DEFAULTMETHOD/M
-// 48:
+// 48:        INFERRED
 // 49:
 // 50:
 // 51:    lateDEFERRED
@@ -182,6 +182,12 @@ class Flags extends ModifierFlags {

   final val SYNCHRONIZED  = 1L << 45      // symbol is a method which should be marked ACC_SYNCHRONIZED

+
+  /** A transient flag to mark a val or def haswith an inferred result type
+   * Guaranteed to be reset after each phase. (Reset by Typer.)
+   */
+  final val INFERRED      = 1L << 48
+
   // ------- shift definitions -------------------------------------------------------

   final val InitialFlags  = 0x0001FFFFFFFFFFFFL // flags that are enabled from phase 1.
@@ -441,7 +447,7 @@ class Flags extends ModifierFlags {
     case        SYNCHRONIZED => "<synchronized>"                      // (1L << 45)
     case            ARTIFACT => "<artifact>"                          // (1L << 46)
     case       DEFAULTMETHOD => "<defaultmethod>"                     // (1L << 47)
-    case    0x1000000000000L => ""                                    // (1L << 48)
+    case    0x1000000000000L => "<inferred>"                          // (1L << 48)
     case    0x2000000000000L => ""                                    // (1L << 49)
     case    0x4000000000000L => ""                                    // (1L << 50)
     case      `lateDEFERRED` => "<latedeferred>"                      // (1L << 51)
diff --git c/src/reflect/scala/reflect/internal/Symbols.scala w/src/reflect/scala/reflect/internal/Symbols.scala
index 8343ae6b07..bae38e9728 100644
--- c/src/reflect/scala/reflect/internal/Symbols.scala
+++ w/src/reflect/scala/reflect/internal/Symbols.scala
@@ -162,7 +162,6 @@ trait Symbols extends api.Symbols { self: SymbolTable =>
     rawatt = initPos

     val id = nextId() // identity displayed when -uniqid
-    //assert(id != 3390, initName)

     private[this] var _validTo: Period = NoPeriod
